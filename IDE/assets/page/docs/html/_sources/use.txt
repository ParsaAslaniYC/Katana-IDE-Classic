.. _use:
								   
Using PAGE
=========================

PAGE is built upon the program Visual Tcl, but is different because of
differing objectives of the two programs.  Visual Tcl was conceived as
complete build environment for Tcl. It included facilities for
managing projects with multiple windows, creating of GUI's, binding
actions with callback procedures, creating menus, writing functions,
and testing the application, all the while supporting many different
widget sets and several geometry managers. PAGE is limited to defining
a single GUI window using Tk and ttk widgets and the placer geometry
manager; there are better environments for building and debugging
Python programs once you have code for the GUI.

PAGE makes use of the Virtual Tcl facilities for creating a single GUI
window, assigning attributes to widgets, binding events to callback
procedures, and creating menus. PAGE also automatically generates
skeletal callback functions and supplies much of the boilerplate code
for running Tkinter.

When PAGE generates the code for a window, all of the code for causing
Python to create and map that window is generated - a Python class for
the toplevel window with all the code necessary to instantiate the
class (i. e., display the window), import statements, Tk mainloop and
initialization, a main procedure, etc.  Therefore, if you have
provided the skeletal callbacks the generated code is executable and
you can see just how the GUI will look in a Python environment. PAGE
even attempts to generate skeletal callbacks. As mentioned above the
generated code resides in two modules.

The generated code can be used as the skeleton for your application.
However, the generated GUI may be a secondary GUI and all that you
really want to do is instantiate the toplevel class, use support
functions implied within the GUI and possibly to destroy that window.
You can do that by importing the code as a module and invoking
functions within that module including automatically generated
functions for creation and destruction of the window. This will be
discussed in more detail later.

I often use the generated GUI classes as starting points for
customization. When you are not sure how to start or want to quickly
try out some GUI ideas, PAGE is very useful because it generates all of
the boilerplate necessary.

PAGE is invoked by executing the "page" script located in the page
directory. I go to that directory and issue the command:

.. sourcecode:: python
    
    ./page [options] [filename]


==============    =================================
PAGE Options
==============    =================================
   null            rcfile is ~/.pagerc
--p <profile>     rcfile specified by filename
---d               no rcfile, use default values
---s               select the rcfile to be use
---help            print help message. No execution.
==============    =================================

I preface the command with "./" to be sure I am executing the page
script in the page directory. By including "page" in the PATH
environmental variable, one can work in any directory. 

PAGE can be invoked with zero or one file names.  If supplied the file
name should have an extension of ".tcl" and the file should exist.  If
another extension is supplied that is interpreted as an error and PAGE
terminates. If no extension is given in the file name or the file name
ends in "." , an extension of ".tcl" is assumed by PAGE. If the file cannot
be found PAGE terminates because PAGE expects a file generated by
PAGE.  If a file name is specified, the file should be a tcl file
saved during a previous PAGE session; it will be opened as PAGE begins
executing as an alternative to File->Open for proceeding from a saved
PAGE session.  Near the top of a ".tcl" design file created in PAGE
there is a comment containing version information and a timestamp. If
that version information is not present then PAGE will refuse to open
the file. Due to a user request the filename may contain blanks
starting with version 4.10

As you use PAGE to build a GUI, you can save the current state of the
GUI at any time from the File->Save of File->Save As menu.  In fact,
it is a good idea to save your status often in case PAGE fails or
dies.

I am sometimes exasperated in PAGE because so many functions can be
performed several ways.

.. _naming:

Naming Conventions
``````````````````
PAGE generates several files. The main ones are the project file which
has the extension of ".tcl" and two Python modules with extensions of
".py". The filename portion of the project module (the part of the name
without the ".tcl" is used to name the GUI module and the support
module. Further the name of the support module is incorporated in an
Python import statement and the requires that the name must be a legal
python identifier.

For version 4.10, it was suggested that PAGE check the syntax of
Python function names. This sounded easy but involved several
problems. Function names are identifiers and identifiers in Python 3
are can contain unicode characters whereas identifiers in Python 2 may
not.  A goal of PAGE has been to generate code which is legal in both
Python 2 and Python 3. So if you want PAGE to check your identifiers,
stick to Python 2 identifier rules.

I have since decided that this was a bad idea and decided not to use
it. There are too many special cases and it certainly does not fit
with the move to Python3 in the near future.  In a few releases I will
probably remove it. With release 4.23, it's gone.

Prior to 4.18, text attributes for Toplevel and Menu widgets were
massaged and then incorporated into Python variable within the
generated code as the toplevel class name and submenu names. That was
really bad and caused errors. This was changed in 4.18 so that the
toplevel class name is the Toplevel widget alias just like any other
widget while submenu names are completely manufactured. The main
effect of the change of class name will be felt when a support module
invokes a new toplevel window.  In such a case the user will have to
be careful with the name/alias.  I hope here will be no problems with
menus beyond readability.

In version 4.18 Tkinter import statements have been changed from

.. sourcecode:: python

   from Tkinter import *

to

.. sourcecode:: python

   import Tkinter as tk

I believe that this will make the generated code more readable while
causing a minimum of inconvenience.

Overview
````````

This section attempts to describe the main functionality of PAGE when
building an application with a single root window. It will yield a
Python module which implements the application interface.

One uses PAGE to generate a GUI as follows:

+ Start PAGE by executing "page" or activating the PAGE icon on
  the Windows desktop. In Windows one may also start PAGE from the
  command line by going to the installation directory and executing
  winpage.bat. This will create a toplevel window which you can then
  populate.
+ Drag the toplevel window to where you want it.
+ Resize the toplevel window by dragging a corners or an edge.
+ Change the title by changing the title attribute in the Attribute Editor.
+ Add a menu to the top level using the Menu Editor entered from
  Widget->Edit Menu in the main menu.
+ Drag appropriate widgets from the tool bar to the toplevel window or
  other previously placed container widgets.
+ As desired to make the generated code more readable, specify an
  unique alias for the widget.
+ Adjust properties of the widgets and the toplevel window as desired.
  Some of those properties will include specification of functions to
  support the GUI such as to load list box, or to respond to mouse
  selection, etc. Included can be the specifications of event bindings.
+ Use the function definition facilities to specify the necessary
  functions and use the bind specification facilities to bind events to
  functions.
+ When the window has the appearance that you want, select
  Gen_Python->Generate Support Module. A new window will appear and fill
  with the skeleton functions and the definitions of the Tkinter variables.
  Save the source window of the python console.

+ Then select Gen_Python->Generate Python GUI from the main menu.  A
  new window, a Python Console will open and fill with the Python
  code, which I call the GUI module. To generate the support module
  select Gen_Python->Generate Support Module, which creates and fills
  another Python Console with the generated skeleton support module.

+ You can save the code in  one or both of the Python modules and then
  try executing the GUI module to see if you like what you have designed.



.. Placing and Modifying Widgets
.. ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



Toplevel Geometry
`````````````````

PAGE generates a single Toplevel Tk window which is the users GUI for
his application. (One can have multiple GUI windows; see
:ref:`Applications with Multiple Top-Level Windows`.)  
As elsewhere with Tk and PAGE, there is more than one way to specify
where the GUI window will appear on the application user's
screen. 

Prior to release 4.5, the PAGE user would select the Toplevel button
in the Widget Toolbar and a toplevel window would appear on the
screen. As well as filling in subwidgets the user could drag the
toplevel widget to the desired screen location and also could adjust
its size.  When the Python code was generated it would contain code
that would place the GUI at the exact spot specified.  If you had
placed it at pixel specification +1000+300, it would end up 1000
pixels from the upper left corner and 300 pixels down. If the Python
code was then executed on a machine with a screen size of less than
1000 pixels, the GUI would not appear; it had been placed beyond the
edge of the screen.

.. Similarly for a
.. size spec corresponding to 400x300. Fine if the target screen is the
.. same resolution as the design screen.  
.. However, if the target screen
.. has higher resolution than the design screen, then the GUI would
.. appear scrunched up toward the upper left corner of the screen.  The
.. opposite effect will occur if displayed on a screen with lower
.. resolution. The other effect of differing resolution between the PAGE
.. screen and the target screen is that the GUI window could resize from
.. poster size to stamp size.

.. _origin:

With version 4.5, the Python code generation addresses the toplevel
placement with a new attribute - "default origin".  The "default
origin" preference, if selected will cause the generated Python GUI
window to placed on the screen at the default location as determined
by the system window manager.  If false, the location will be
determined from where the toplevel window is placed in PAGE. The
default for the this attribute is false, but can be changed by means
of the Preferences mechanism. A default of false will cause PAGE to
behave as before. Unfortunately, I was faced with an unclear mnemonic
in the Attribute Editor or a double negative; I chose the latter.

.. The "proportional geometry" attribute works as follows.  The width of
.. the toplevel window is expressed as the ratio of the actual width in
.. PAGE to the screen width of the PAGE screen. Similarly for height and
.. x location and y location.  These ratios are then embedded in the
.. generated Python code where they are multiplied by the screen
.. dimensions of the target screen to determine the actual geometry of
.. GUI window. When combined with relative placement of the widgets
.. inside the toplevel window, things may work out satisfactorily. The
.. default value for this attribute is false but by may be changed with a
.. Preferences setting. This leads to the same behavior as prior
.. versions. Proportional geometry is related to :ref:`relative`.

.. My recommendations are as follows.  The simplest case that avoids the
.. most trouble is to use the default origin and not to use proportional
.. geometry. This will work fine in the case where you use the GUI on your
.. own screen or screens with similar resolution. If you have multiple
.. GUI windows, then you may want to fix the GUI window locations. Use
.. proportional geometry when you know there will be resolution problems.


.. Adding Widgets
.. ``````````````

.. All that is necessary to add a widget to the GUI is to select it with
.. Button-1 from the Widget Toolbar, position the cursor inside the
.. destination container and again press the Button-1.  A small version
.. of the widget will appear with its upper left-hand corner at the point
.. of the Button-1 click.

Prior to version 4.26, the geometric attributes of toplevel widgets
resize, minsize, and maxsize were ignored when generating the GUI
module. That is now corrected. Users can now specify these values and
they are reflected in the generated Python code.  Note that the default
values of maxsize are determined by the screen size of the users
computer while the default value of minsize is 1 pixel.  Users should
really set reasonable values for the minsize and maxsize.


Aliases
```````

Often algorithmically generated names can be difficult to understand
in computer generated code.  To reduce the problem in PAGE, users can
specify more easily understood names called aliases.

An alias is a user specified identifier of a widget in the generated
code. Obviously, aliases must be unique within the class which will be
generated in the python code to realize the GUI window. 

* An easy way to specify an alias is to select the target widget with
  a Button-3 click and then select "Set Alias ...".  Another small
  window will appear and one can add the alias. Finally close that
  window by selecting the "check" or with the Enter key.

* Another way to enter an alias is to select a widget with Button-1
  and then select "Set Alias ..." from the Option menu in the main
  PAGE window.

* Also, one may specify an alias by selecting a widget and editing the
  "Alias" field in the top section of the Attribute Editor.

An alias must be a legal python identifier.  PAGE does allow blanks in
an alias but they will be changed to "_".  Also Alias has no meaning
for top level windows.  For top level windows the variable names are
generated from the title attribute. There are numerous schemes for
generating such names but one that has been suggested is based on
CamelCase. It is:

+ Buttons could start with 'btn',  i.e. btnQuit, btnNew, etc.
+ Entry boxes could start with 'txt', i.e.  txtFirstName, etc.
+ Check boxes could start with 'chk' I.E. chkDoThis, etc.
+ Radio Buttons could start with 'rdo' or 'rbtn'.

Note that PAGE has an option to automatically generate aliases.  These
aliases are algorithmically generated name but are more readable than
the default generated names.  This is controlled by a new field in the
Preference window.  I recommend that you go into Preferences, check
the value and save the preferences.

Balloon Help - Tooltips
```````````````````````
Starting with version 4.21, PAGE supports balloon help also call
called tooltips with many of the widgets. The scrolled widgets do not
support balloon help.

To use balloon help with any of the supported widgets, merely select
the widget and supply the desired tooltip message in the attribute
"tooltip text" in the Attribute Editor.  If balloon help is available
The message may be multi-line by including "\\n" as line breaks.  For a
given widget that attribute will be present in the Attribute
Editor. If you do not wish to use tooltips just ignore the "tooltip
text" attribute; the balloon preference checkbox has been eliminated
from the preference window.

The tooltip message may also be specified from the Widget sub menu of
the widget popup menu which is accessed by selecting Button-3 while
the widget is selected.

The Tk default font is really tiny, so the Preferences have been
extended to allow specification of the tooltip font.

The tooltip support was made possible by the work of Greg Walters. He
developed a package which the user could easily incorporate in a
support module. I realized that his package could be also be easily
incorporated into PAGE with minimal change.

Selecting and Modifying a Widget
````````````````````````````````

Selecting a widget is key to modifying a widget.
There are several ways to select a widget for modification and I don't
want to keep repeating the variations through out this document.


+ For simple widgets like buttons or text boxes you can select the
  widget either by selecting the widget with Button-1 in the GUI or in
  the Widget Tree.

..

+ With more complex widgets like notebooks, paned windows, or scrolled
  widgets, which have child widgets inside the main widget clicking
  Button-1 inside the widget will select a child widget rather than
  the whole widget.  The parent widget may be selected with
  Control-Button-1.

..  
  
+ In the case where a widget is embedded in a container such as a
  frame, the container can be selected with Shift-Button-1. This is
  particularly helpful when a widget fills the container and you want
  to modify the container.

..  
  
+ Finally, the widget may be selected with Button-1 in the Widget
  Tree.  This is particularly useful with the complex widgets
  mentioned above and also for selecting frames which have been filled
  with child widgets.
  

Once selected there are several ways to modify the widget.  The
location and the geometry may be altered as well as the attributes of
the widget:

+ A selected widget may be moved by dragging the widget or resized by
  dragging a handle. When the mouse is over a handle, it turns red.

..  

+ Attributes can be changed in the Attribute Editor. Geometric
  attributes can be changed Attribute Editor also.

..  
  
+ Some changes can be made using the Widget popup menu.


If you are working with standard Tcl widgets, there are many options
that can be modified whereas the ttk widgets have very few options,
their appearance being governed principally by the specified theme.


.. _multiselection:

Multiple Selection
``````````````````
A limited facility for using multiple selection of widgets has been
added to PAGE. So far the use of multiple selection has been limited
to the :ref:`Stash and Apply <apply>` facility and the Attribute Editor.
Multiple selection basically creates a list of widgets to be used by
the Apply function and the Attribute Editor.

Multiple selections are made by selecting widgets with Button-2 or
Control-Button-2 in the case of complex widgets. This is similar to
simple widget selection. When a widget is so selected, the handles are
a different color for emphasis.

Multiple selection does not change any regular selection.
Selecting a widget which is one of the multiple selections removes the
widget from any multiple selection and performs selection.

To clear all multiple selections use Options->Remove Multi Selections
from the main menu or uses the Control-Delete key pair. To remove one
widget from the multiple selection use shift-button-2. Early in the
implementation the user was able to clear all multiple selections by
doing a regular selection but I found that frustrating and removed it.

I considered extending the facility for deleting widgets to remove all
the multiple selection widgets felt that that would be too
prone to error. And I have not seen how to extend copy and paste to
handle multiple selections.

Selection and geometry events are summarized in the following table of
related key pairs:

=============================     ============================================
Widget events                     Function
=============================     ============================================
Button 1                          Select Widget
Control Button 1                  Select complex widget (like Scrolled widget)
Shift Button 1                    Select the containing widget
Delete                            Deletes Selected Widget
Move Button 1 inside widget       Move widget
Move Button 1 inside handle       Resize widget
Button 2                          Add to multiple selections
Control Button 2                  Add complex widget to multiple selections
Shift Button 2                    Remove widget from the multiple selections
Control Delete                    Clears all Multiple Selections.
Arrow Keys                        Nudges the widget position 1 pixel
Shift Arrow Keys                  Nudges the widget size 1 pixel
=============================     ============================================

Modifying the Geometry of a Widget
``````````````````````````````````

Geometry refers to the location of the widget as well as its width and
height.

Like many things in PAGE, there are several ways to change the geometry:

+ A selected widget may be moved by dragging the widget or resized by
  dragging a handle. When the mouse is over a handle, it turns
  red. For complex widgets, it is necessary to depress the Control key
  while dragging.

.. _arrow:   

+ The arrow keys may be used.The arrow keys offer a way to make minor
  adjustments to the geometry of a selected widget. The arrow keys
  move the widget a short distance in the obvious way.  Shift with the
  arrow keys change the size in the obvious way while leaving the
  northwest handle anchored. I find the arrow keys very useful when
  trying to align or space widgets. However arrow keys do not modify
  toplevel widgets. This usage of arrow keys works with locked widgets
  as well as unlocked widgets.

.. 

+ The geometric attributes in the Attribute Editor may be changed.
  The bottom section of the Attribute Editor contains a number
  editable attributes which when changed immediately affect the widget
  geometry. For instance, if you want a widget located half way across
  its container set "relative x" to be 0.5.  If you want it to be 300
  pixels down from the top, set the "y position" to 300. You can do
  similar things with width and height.

Locking the Geometry of a Widget
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

There are times when one wants to lock the position of a widget within
its container to avoid inadvertently moving or resizing it with the
mouse. That can be accomplished by selecting the lock widget command
from the context menu.  That is, select the widget and click Button-3
to bring up the context menu and then select "Lock Widget". "Unlock
Widget" has the obvious effect. When a widget is locked, that fact is
noted in the Widget Tree. With version 4.17, locking is displayed and
can be changed with the "locked" attribute in the Geometry region of
the Attribute Editor.

A locked widget can still be move and resized by changing values in
the geometry section of the Attribute Editor as well as with the arrow
keys, see :ref:`use of arrow keys <arrow>`. In fact, the adjustments
need not be multiples of the default grid.  Of course, the container
widget geometry can be modified with the mouse if not locked.

Fill Container
~~~~~~~~~~~~~~

"Fill Container" is a feature that was added in version 4.8 and causes
the selected widget to expand to fill its container provided that
there are no other widgets already in the container. This function is
restricted to those widgets for which I think it makes sense, like
frames, notebooks, scrolled widgets, canvases as well as text and list
boxes. 

To use this feature activate the Widget popup menu with Button-3 over
the widget itself or an entry in the Widget Tree and select 
"Fill Container" from the widget submenu.

Once you have filled a container using this feature, you can select
the container with Shift-Button-1 to move or resize it with the mouse.
You can also select the container in the Widget Tree and then change
the x and y coordinates in the Geometry section of the Attribute
Editor.


Cut, Copy, and Paste
````````````````````

After much work I think that there is now a useful cut, copy, and
paste feature in PAGE.  The basic way it works:

+ Select the widget you want to paste in a new spot or container by
  selecting it as you would for just plain moving it.
   
..  
  
+ With Widget Menu and select with Button-1 Cut or Copy as you want.
   
..  
  
+ In the Widget Menu select Paste or use Control-V or select Paste
  from the Main menu -> Edit.
  
..  
  
+ Move the mouse to the desired insertion point and click Button-1.

It is possible to cut, copy, and paste complex widgets such as frames
containing multiple widgets like a row of buttons, or notebook
widgets, etc..
  
With version 4.11, copy and paste work with menu bars.

Copy and Paste are important features because one cannot drag a widget
from one container widget into another but one can cut or copy and
paste to get that effect.  For instance if one creates a button in a
top level window and then decides that it should be moved to a frame
or a notebook tab, that cannot be accomplished that just by selecting
the button and dragging it to the frame. However it can be done with
cut and paste.

When doing cut-copy-paste I make fewer mistakes by selecting the
widget the Widget Tree than trying to grab it in the top level window.
Correct selection is crucial important when trying to select and copy
nested widgets.

I have implemented cut and it appears to work; however, I never use
it. There is a sequence of several steps between the selecting copy
from the menu and selecting the location of the paste.  If you get it
wrong following a cut, you can't go back and retry the operation; the
source for the copying is gone. So, I stick to copy and paste and then
finish with a delete.

One thing that cut, copy, and paste can do is copy from one project
GUI and paste in another project GUI. That usage is addressed in the
reuse section. See :ref:`reuse`. Note: if you copy-paste a widget
containing images then you better update the image to be one resident
in the new directory.

Note: if you copy-paste widgets which have variables defined, then
strange things will arise. For instance, if you create a button and
set its text to "Button" and then define the text variable to
"zzz". The variable will have the value of "Button".  When you copy-pate
the Button widget, the new widget text will be determined by the value
of "zzz" and be "Button". Changing the text attribute will have no
effect. To change the initial value of text of the new widget you will
have to delete the variable entry, change the text attribute and the
add the variable. You probably don't want to use the same text for
more than one button widget.

Note: if you copy-paste a widget containing images then you better
update the image to be one resident in the new directory.

.. _apply:

Stash and Apply - Propagate Widget Options
``````````````````````````````````````````
It is possible to propagate options from one widget to other widgets.
One may save the configuration of a particular widget and subsequently
apply selected options to other widgets. This is similar the function
of the context menu of the Attribute Editor. Thus one may easily align
widgets, make buttons the same size, make the background colors the
same, and make other options identical.

.. _stash:

The current options of the selected widget are stored , "stashed", by
selecting "Stash Config" from the Widget context menu. The stashed
options are displayed in the Apply Window.  Since a given widget can
contain many options, only the options which have values different
from the default value as well as height and width are displayed.

The options to be propagated are checked in the main subwindow. The
destination is based on the currently selected widget.

In the Apply Window,  Apply menu item in the
menu bar leads to two similar submenus:

.. image:: apply-submenu.png		   

The first entry "Current Widget" causes the selected options to be
applied to the currently selected widget.  To apply stashed options to
another widget, one selects the receiving widget from the GUI or the
widget tree, checks the options to be applied, and finally selects 
"Current Widget" from the Apply submenu.

The next entry "All widgets in Multi Selection" will apply all of the
checked values to each of the widgets in the multi selection. This
leaves the selection unchanged.

The next entry "All widgets in Toplevel applies the options to all
widgets in the Toplevel but not to the Toplevel itself.

The final entry "All widgets same in class same parent" does not
change options of the parent. This ability is a good argument for
grouping widgets into container widgets like frames.

Very similar functions are supplied which will change widget options to the
default value using the "Reset to default" submenu of apply.

In case you have a window open for using the borrow function, this
mechanism will only modify widgets in the primary toplevel, i.e., it
does not modify widgets in the borrow toplevel.

What is written above describes option propagation via the Stash and
Apply mechanism.  Essentially the same function can be realized by
Button-3 selection of the option name filed of the Attribute Editor.
However, that propagates only one option value at a time whereas the
Stash and Apply will handle multiple options.

Widget Menu 
```````````

The Widget Menu, which appears in more than one place including the
main menu as well as the drop menu in the Widget Tree or a top level
window, provides a convenient way to modify some of the widget
attributes. The drop menu is activated with Button-3 applied to the
selected widget and its features are dependent on and apply to the
widget selected. It is seen below:

.. image:: widget-menu.png

In the case above the widget submenu allows one to easily specify the text
attribute and for specifying multiple line text labels.

Callback Functions
```````````````````
The point of building a GUI is to link actions (the execution of
specific functions called callback functions) to some event within the
GUI like selecting a button with a mouse key, typing a particular
character into a text field, resizing window a widget, etc.. Callback
functions are referenced in either the command attribute of a widget
such as a button or in a bind statement.

The implementation of the callback functions is located in the support
module with one exception - popup (or context) menus which are
generated in the GUI module.  Popup menus will reference callback
functions which are located in the support module.

With release 4.14, it is possible to list the callback functions which
have been referenced in the GUI.  That is done from the main menu or
by the Alt-C shortcut. When invoked the new function opens a special
window to display all of the callback referenced in the GUI along with
the name of the referencing widget. This is done by processing the
widget tree. If you have also created the Python GUI and support
module, double clicking on the callback function line, a Python
console will open and display the callback function implementation.

Linking Events to Callback Functions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

I will not try to explain event binding fully for Tk and Tkinter. I have
read several books and many web pages on the subject but feel little
mastery.

Binding events to widgets is a very confusing aspect of using Tk and
Tkinter.  Tk implements a global binding hierarchy in that Tk allows
one to create bindings between actions and

(1) events within a particular widgets such mouse selection and a
    particular button, 

(2) events within particular classes of widgets such as mouse selection and
    all buttons in an application, 

(3) events within all widgets in a
    toplevel window, and 

(4) events within all the widgets in an
    application. 

PAGE really assists in only the first type of binding. At least one
respected documenter recommends against using the other three. If you
feel it is necessary to class bindings, they can be manually added to
the "init" function in the support modules.

Grayson, in his book talks about invoking callbacks directly or
indirectly. Specifying a command attribute leads an indirect invocation
while specifying a bind command leads to a direct invocation. The
difference is that the direct invocation passes an event object to the
callback and the callback function must have an argument list which
includes a parameter for the event. To see examples of direct and
indirect invocation of callbacks see the vrex example or the bind example.
One could also characterize them as clear and confusing, or easy and complex.
Let me discuss the easy case first, that of specifying a a command attribute.

Many widgets have a command attribute which specifies the code to
executed when the widget is selected with Button-1.  This is a
simplified way of binding for the common case of selecting the widget
with Button-1.  While Tk allows one to specify a block of code, one
must stick with a function call in Python.  For example, setting the
command attribute of a button to "foo" so that selecting the Button-1
will cause the invocation of the function "foo" without arguments.


If you want to invoke a function and pass parameters to it, you use a
lambda expression. Please see section 6.4 of Grayson's book for a fine
explanation of the use of lambda expressions in this context.  (In a
nutshell, if Python encounters a function name followed by parenthesis
it will try to execute the function immediately, whereas the execution
is desired when the event occurs.)  Let say that if you want to call
the function foo and pass it 3 as an argument, what you enter as
command is

.. sourcecode:: python

    
    lambda : foo(3)


not

.. sourcecode:: python

    
    foo(3)

or to pass a variable parameter

.. sourcecode:: python

   lambda x: foo(x)

not

.. sourcecode:: python
   
   foo(x)


To specify such a command, one selects the widget and then in the
Attribute Editor enters the command in the Command field. In keeping
with the Virtual Tcl style of having too many ways of doing most things, an
alternative is to select the widget in the Widget Tree with Button-3
and then Widget->Set Command. I don't use the alternate method very
often. I would probably forget it but for this paragraph.

.. _entrycmd:

When it comes specifying "validatecommand" and "invalidcommand"
options of the Entry widget or Tk_entry widget the command string must
be a list with first element is the command name and the additional
elements may include the following script substitutions:

* %d = Type of action (1=insert, 0=delete, -1 for others)
* %i = index of char string to be inserted/deleted, or -1
* %P = value of the entry if the edit is allowed
* %s = value of entry prior to editing
* %S = the text string being inserted or deleted, if any
* %v = the type of validation that is currently set
* %V = the type of validation that triggered the callback
       (key, focusin, focusout, forced)
* %W = the tk name of the widget

An example of a possible validation command entered in the Attribute Editor:

.. sourcecode:: pythton
   
   vcmd %P %S %W

Note that this is a change from earlier documentation. 
   
So what will happen is that the Python will rewrite the list as a
tuple with the script substations encased in quotes. It is unclear
from the documentation that I found if other parameters are allowed
but I would guess that they are permissible.  In addition, a skeletal
function vcmd will be created by PAGE in the support module with a
variable number of parameters. In the case of the example above the
value of entry being the first argument, the string being inserted as
the second, and widget information as the third parameter.  Be warned
that %W does not pass the widget, it passes the widget converted to a
string.  I think it is a bug in tkinter. It certainly does not behave
in the same way in tkinter as it does in Tcl/Tk.

The skeletal function looks like:

.. sourcecode:: pythton

    def vcmd(*args):
        print('v2_support.vcmd')
        for arg in args:
            print ('another arg:', arg)
        sys.stdout.flush()
        return True

Note that the validation function must return either True or False.

So much for the binding of the easy case which essentially defines a
configuration command for setting the command attribute of a widget in
the generated Python.  For binding other events to widgets I point you
to the Bindings Window which builds a bind command. Of course, the
bind command could be manually coded in init function of the support
module.

For many widgets the command attribute is the way to go and it is
tempting to think of <Button-1> as the associated event. Actually,
<ReleaseButton-1> is the associated event. The difference can be
important. For instance, the Checkbox widget sets the associated
variable to the new value as the last step of the <ReleaseButton-1>
event.

Another zinger is that while the command attribute will generally pass
zero arguments or the parameters specified in the lambda function. In the case of
Scale and TScale widgets, the final value of the scale is passed to
the callback function as the first argument. See :ref:`scale`.

Bindings Window
~~~~~~~~~~~~~~~

There are many events that can be linked to code. See the Tk man pages
and Chapter 6 of Grayson. They include responding to the different
mouse button pressings or releases, a window gaining or loosing focus,
etc. as well as virtual events. Bind is the command for linking one of
these events to code and is accomplished by using the Bindings Window.
Here the code must be a lambda expression because it pass an event
object containing much useful information to the
callback. Consequently, the callback function must have an event
parameter in its argument list.

The Bindings Window can be opened by selecting the widget with
Button-3 and the selecting Bindings... from the popup menu. Basically,

(1) select the widget in the left column if not already selected, 

(2) Insert the desired event from the Insert menu, 

(3) select the item in the left column, and 

(4) fill in prototype lambda expression in the right hand column.

The Bindings Window can be opened either from the popup menus in
response to selecting the widget with Button-3 or selecting the widget
with Button-1 and typing Alt-b. Then select Insert from the menu to
put the event in to the left pane.  Finally insert the desired code in
the right pane where a template will appear.

.. Some virtual events are defined within the Tcl/Tk for things like cut,
.. copy, and paste as well a special virtual events for different Tk
.. widgets. The bindings mechanism will handle bindings for those virtual
.. events but there is no supported mechanism for creating such
.. events. For instance, with the Scrolledtext widget one can select the
.. text widget, type Alt-b to enter the binding editor, choose Insert
.. then Advanced, scroll down to show <<Cut>> and select it, then the Add
.. button and it will appear in the right window of the binding editor
.. where one specifies the name of a routine say xxx, then select the check to
.. commit it.  When on then run the program, selects some characters in
.. the text box and then Ctrl-C, the built in trigger for Cut, the
.. routine xxx in the support module will be called.

Let's clarify that and look again at 


.. image:: binding.png

In the left column you will see the Tcl name of the selected widget and
below the name a list, initially empty of the events already bound to
the widget.  In the image two events have already been bound, one of
which is a user defined virtual event, "<<Bingo>>". 
Following the event information of the selected widget is a bunch of
information about the bind hierarchy related to the selected widget. I
have not found any use for that stuff.

Two things can be accomplished with the Binding Window are: 

(1) define a new binding for the selected widget The key action for
    the first is to insert a new event. It is done by clicking Insert
    Menu and selecting one of the actions there.

(2) modify the lambda expression of an existing binding in the obvious
    way.  

Selecting Insert yields

.. image:: insert-bind.png

If you do not find the action you can select Advanced ...

.. image:: advanced-bind.png

Here you are presented with a wide selection of possibilities. 

First, if you want the event to be the pressing of the key c, select
the entry box at the top and type "c"; the event "<Key-c>" appears in
the Event entry box near the bottom. If you want to modify the event
to require the control key at the same time, select Control from the
right column and the event becomes "<Control-Key-c>". 

For events other than a key press event, then select an event from
the left column.  The list of events there is more or less every event
Tk knows about. I know of no way of listing only those events to which
a particular widget will respond, so I can't prune the list.

Again, the selected event may be modified by picking a modifier from
the right column. Notice that the left column contains all of the
virtual events that Tk knows about. Unfortunately, Tk skips several
and I have tried to add them but I probably missed some.  If you are
going to generate code for a user defined virtual event, say
<<Bingo>>, or one missed by Tk, you can add that virtual event to the
Event entry box manually. Yes, you may edit the Event entry box.

Having now composed your event, you can select the "Add" button
which will close the insert window and add the event to the left
column of the Binding Window.

The penultimate step is to appropriately change the skeletal code in
the right column. Basically, just add parameters and supply the
callback function name in place of "xxx". Finally, save the result by
selecting the check button.  This is similar to the situation with the
command already discussed.

Elsewhere in this document I have used the term callback to mean the
callback function that appears in the Python support module. At the
binding level the 'real' callback function is a lambda function which
invoked the callback function in the support module.

The big thing here is that the 'real' callback is always passed a
parameter, the event object, and so a lambda is needed to receive that
object and invoke the Python callback passing any parameters to the
callback function. Those parameters may or may not include the event
object. The dummy lambda in the Bindings Window assumes just one
parameter, the event object. This means that the lambda for passing
the event object (with no user parameters) is:

.. sourcecode:: python
    
    lambda e: foo_bar(e)

or if passing user parameters:

.. sourcecode:: python
    
    lambda e: foo_bar(e,5)

Of course, if no parameters, not even the event object, is needed by
the callback function the following forms may be used:

.. sourcecode:: python

   lambda e: foo_bar()

or 

.. sourcecode:: python

   foo_bar

.. _event:
   
The parameter e above is the event object which contains much
information about the event. The event object has the following attributes
(from the documentation found in Tkinter.py):

.. sourcecode:: python

    
        serial - serial number of event
        num - mouse button pressed (ButtonPress, ButtonRelease)
        focus - whether the window has the focus (Enter, Leave)
        height - height of the exposed window (Configure, Expose)
        width - width of the exposed window (Configure, Expose)
        keycode - keycode of the pressed key (KeyPress, KeyRelease)
        state - state of the event as a number (ButtonPress, ButtonRelease,
                                Enter, KeyPress, KeyRelease,
                                Leave, Motion)
        state - state as a string (Visibility)
        time - when the event occurred
        x - x-position of the mouse
        y - y-position of the mouse
        x_root - x-position of the mouse on the screen
                 (ButtonPress, ButtonRelease, KeyPress, KeyRelease, Motion)
        y_root - y-position of the mouse on the screen
                 (ButtonPress, ButtonRelease, KeyPress, KeyRelease, Motion)
        char - pressed character (KeyPress, KeyRelease)
        send_event - see X/Windows documentation
        keysym - keysym of the event as a string (KeyPress, KeyRelease)
        keysym_num - keysym of the event as a number (KeyPress, KeyRelease)
        type - type of the event as a number
        widget - widget in which the event occurred
        delta - delta of wheel movement (MouseWheel)


A couple of points need mentioning. First, the Binding Window contains
a lot of cruft below the event entries for the selected widget which I
don't understand and can't use. It seems to be a listing default events for the
binding hierarchy of the widgets alluded to above. I am toying with
just removing it. In addition I have never done anything good with the
buttons below the menubar except for the check button which saves the
bindings, or the 'x' button which deletes an event binding. 

The left listbox in the Binding Window has a popup menu which lets one
modify the event under the mouse pointer.  For instance, it allows one
to easily change the event <Button-3> to <Double-Button-3>.

With version 4.8, Custom Widgets were introduced. Since PAGE knows
nothing of those widgets including binding possibilities, the
mechanism just described cannot be used to specified bindings for such
widgets. You will have to do that in the support module.

Creating Bindings for Scrolled Widgets
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The scrolled widgets are implemented as Python wrappers for underlying
tk widgets such as text boxes, so in order to bind an action to the
text box of a Scrolledtext widget, use the Bindings Window to bind the
action to the Scrolledtext widget rather than the Text subwidget.

.. _specifying_fonts:

.. _defining_functions:

Defining Callback Functions
~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you name a function in a menu, an event binding, command attribute,
etc., that function is called a callback function and a Python
implementation of that function is required before trying to execute
the GUI in PAGE.

Executing the GUI means executing the generated Python code within
PAGE to demonstrate how the GUI will appear in the completed
application.This is done by selecting the Run button on the Python
Console or with the shortcut Control-R.  To satisfy requirements of
the Python interpreter, Tkinter variables and callback functions have
to be defined. These functions are to be located in the support
module.  Skeleton functions will be satisfactory since at that state
of development you really don't expect the application to usefully
function.

One path for the user is to do nothing, letting PAGE create a skeleton for
you by just noticing that the a name is specified in a binding or a command
attribute in the support module as described in :ref:`rework`.  This
is the recommended approach as of version 4.2.  

.. Previously, I did a makeover of the Visual Tcl function definition
.. facility. While satisfyingly clever, I now have abandoned it for the
.. simpler creation of skeletal functions. 

.. Though deprecated, it is described below.

.. comment the following Rozen 11-8-14
.. If you wish to have a more complete function then go to the function
.. list window which is usually open or can be made visible from the
.. Window menu. To create a function hit add. Yet another window will
.. appear filled with a dummy function, py:xxx. See below.
.. 
.. .. image:: function-editor.jpg
.. 
.. To get a skeleton function just change the 'xxx's to the name of your
.. function and fill in the parameter list. If the function is to be a
.. class method be sure to insert "self," including the comma as the
.. first parameter even if you have no other
.. parameters. Obviously, you
.. can write as much of function here as you want.  For instance, I
.. sometimes will include the statement sys.exit() in a quit function.
.. 
.. .. sourcecode:: python
.. 
..    def quit():
..        sys.exit()
..  , because when the event happens
.. An aside:
.. 
.. Since Tcl will tolerate a procedure containing anything until it
.. executed, PAGE will save your function as:
.. 
.. .. sourcecode:: python
.. 
..    ## Procedure:  py:wet
.. 
..    proc ::py:wet {} {
..    def wet(self,) :
..        pass
..    }
.. 
.. That means that later you can come back to PAGE to modify the GUI and
.. the functions that you saved will still be there! This ends the
.. discussion of the deprecated function stuff.

I usually just let PAGE generate the skeleton functions, run the
resulting code to see what my window will look like and then do the
rest of my programming in emacs. When PAGE stores the python modules,
several layers of backup files are retained.  If I need to regress to
one of them, I find that `Meld <http://meldmerge.org>`_ is a
wonderful utility for managing the differences between versions.


.. Previously, the automatically generated functions contained only a
.. single "pass" statement. Unfortunately, that tells you little when you
.. try executing the generated Python code in the Python Console.  So I
.. preceded the "pass" statement with a print statement which prints the 
.. function name when the function is called. I have found that to be
.. helpful. 


.. Special Widget Processing
.. ~~~~~~~~~~~~~~~~~~~~~~~~~

Viewing Callbacks
~~~~~~~~~~~~~~~~~

In release 4.14, a facility for listing and copying callback functions
was added. This can be activated from the main menu - Window->Show All
Callbacks - or from the Widget Menu, the context menu. The first will
display in the Callback Window all callbacks defined for the GUI,
while the latter displays only the callbacks related to the selected
widget. A particular callback can be selected with the mouse or the
search feature of the callback window.  Then the "Look up" button will
find that callback in the Python Console; alternatively, hitting
Button-3 in the callback window has the same result as selecting the
"Look up" button. 

If the Python console exists it is used for the "Look up". Otherwise,
it is created and loaded from disk. Care needs to be exercised because
the Python console may be differ from the disk version. Check the save
warning at the bottom of the console.


Specifying Fonts
````````````````

When manipulating most widgets in PAGE, the user can specify fonts to
be used with that widget by means of the font field in the Attribute
Editor. If one selects the ellipsis button - the small button with
'...' - a font selection opens and its use is straight forward. One
may also add a font description in the entry field and that is where
restricted to using Tk font specification formats which are
exemplified below:

.. sourcecode:: python

   -adobe-courier-bold-r-*-*-20-*-*-*-*-*-*-*

   {{deja Vu} 12 bold}

   -family {DejaVu Sans} -size 12 -weight bold -slant roman -underline 0 -overstrike 0


Toplevel Widget
```````````````
With version 4.10, a Toplevel widget is created when PAGE is invoked
without parameters.

The Toplevel widget is the main widget and the container for the
widgets of the GUI design.  It is created when PAGE begins and cannot
be closed. The exception is when an existing project is opened from
the main menu File->Open. In that case, the existing Toplevel widget
is saved if it had been modified and then replaced with the Toplevel
widget of the opened project

Toplevel widgets don't really have a title property. It was added in
Visual Tcl and the Attribute Editor originally displayed it as one of
the geometry attributes. That didn't seem like a good place, so I moved
it to the Attributes section.  The title is displayed at top of the
window and previously was used to generate the class name use in the
Python code. However the title can be an arbitrary
string of Unicode characters, the alias will be used as the class
name. An alias is automatically generated from the class name and, of
course, may be changed in the Attribute Editor.

Among the attributes listed for a toplevel widget is 'menu' which in
PAGE allows one to easily create  a menubar at the top
of the widget. Click on the attribute and follow the procedure below.

An improvement in version 3.5 was the ability to change other
properties such as the colors and the cursor of Toplevel widgets. One
property of Toplevel widgets is relief.  However, I was totally unable
to change that property at either the Python or Tcl/Tk level.  I
simply don't know how.

With version 4.8.6, the Toplevel widget may be deleted by closing the
window in PAGE with the delete control button in the window title bar
or Alt-F4. Since only one Toplevel widget is allow in PAGE this has
the effect of restarting the design session.

.. _relative:

Relative Placement
``````````````````

Following the paradigm I am familiar with from VB, PAGE uses the place
window manager to fix location within the generated GUI.  Thanks to
George Tellalov, who suggested using relative placement for widgets
within the GUI thus allowing one to build stretchable GUI's.  They
allow one to grab an edge or corner of the executing Python GUI and
change its size and while maintaining relative positions and sizes of
the internal widgets. This is the default behavior. Keep in mind that
with relative placement, widgets may change size as the toplevel
window is resized, but fonts do not change size.

Relative or absolute placement can be selected in the Basics tab of
the Preferences window.

Since I don't think buttons or labels should change size in step with
the change in size of the window, relative placement for buttons does
not change the size of buttons but the relative placement is
maintained. The unit of width with labels is characters, 
width does not change with the size of the toplevel widget.

Relative placement has been extended to the toplevel design widget.
Two design modes are introduced for Relative and Absolute for
PAGE. Relative mode is new and it allows you to see how the completed
GUI will appear as the toplevel window is resized. Absolute mode is
the previous behavior. There is a new button in main window which
displays the current mode and when pressed will convert to the other
mode. The design modes are governed by the following:

+ When the project top level is created the mode is determined by the
  preferences.

+ When the project is saved the mode is determined by the preferences.

+ When the design mode is changed, the selected widget handles are
  preserved.
  
+ When the design mode is changed, multiple selections are lost. (I
  haven't figured out a way to save them.)

+ You can change mode repeatedly, suffering only minor rounding
  errors.

That is, with relative mode in the preferences, the you get WYSIWYG at
the PAGE design level. However, if sometimes, in the middle of a
project design, a flash of inspiration comes and you need to resize
the topmost widget to accommodate more or less space.  With the
relative position in the designer, everything resizing or moving can
throw off hours of work.
This new behavior works best with newly placed widgets. However, with
legacy projects problems may be encountered with widgets located at
position (0,0).
  

When you add a widget in Relative mode, it means that if you stretch,
compress, or diagonally reshape the toplevel widget, the widgets
inside will move around and resize proportionately.

The problem associated with relative placement occurs when widgets are
placed inside of label frames.  To make room for the label, the widget
is taller than the frame and leads to unexpected behavior especially when
compared with simple frames as containers. The user would like to have
resizing and motion relative to the outline of the frame rather than
the origin of the widget.  I have hacked an adjustment to the relative
placement of widgets which have label frames as parent widgets. It
helps but it is not perfect. Suggestions are most welcome.

Tkinter Variable Classes
````````````````````````

With several of the widgets using variable to set or reflect values,
it is necessary to have linkage between tkinter variables and Python
variables.  For instance, when one moves a slider of a scale in the
GUI window, he wants the value to be reflected in a Python variable or
conversely changing that variable should change the position of the
slider. This is done by means of the Tkinter variable classes:
BooleanVar, DoubleVar, IntVar, and StringVar.

You need an instance of one of these classes. PAGE guesses the variable
type which you may need. You can then use the get method in Python to
determine the value of the variable in tk and use the set method to
set the value of the tk variable.  There are examples below.  For more
information see the `Tkinter Variable Class
<http://effbot.org/tkinterbook/variable.htm>`_ on the effbot.org web
page.


For instance if you are using a TScale widget to be coupled with the
tk variable variable "val":

.. sourcecode:: python

    def set_Tk_var():
        global val
        val = DoubleVar()
        val.set(5)   # Initial value to be displayed.

then you need to set the TScale attribute to "val".  The rule is that
the Tkinter variable must exist before it the widget class is
instantiated. It may appear in the toplevel class definition like:

.. sourcecode:: python

            self.che26.configure(variable=app_support.var)

When val is changed

.. sourcecode:: python

   val.set(14)

the TScale will move to that value.

If the TScale is changed in the GUI, you can read the new value with


.. sourcecode:: python

   val.get()

PAGE tries to help out by generating an instance of the appropriate
global class variables as needed in the support module.  Again, this is skeletal code to
help the generated Python code run from within the Python Console.

One point to note: Several widgets such as message, buttons, and label
can use textvariables to set the widget displayed on the widget. If
the variable is created but unset its value is the null string. If the
value is "", then the button has no text and you can't see that there
is a message or label present.  For that reason 4.18 has a hack which
initializes the textvariable to the value of the text option. That
way the widget will appear with same text in GUI execution as in GUI
design. Obviously, the textvarialble can be set in the support
module. In fact, if you didn't expect to modify the textvariable in
support module code, you would not have specified a textvariable.

.. If you forget to specify the variable then try to execute, the code
.. may give an error saying that a variable with a strange name is a
.. problem because a funny name is put into the variable attribute in the
.. Attribute Editor. PAGE tries to detect this situation and give a
.. cryptic error message.

For more discussion of Tkinter Variable Classes see `Tkinter 8.5 reference <https://infohost.nmt.edu/tcc/help/pubs/tkinter/web/control-variables.html>`_.


Ttk Widgets
```````````````
There are some aspects of the ttk widget set that have presented me
with some significant difficulties mainly due to "styles", it may
be merely that I don't understand the ttk widgets well enough or to
problems with their implementation and documentations.  I will try to
explain my problems below. I would welcome any suggestions.


Scrolled Widgets
````````````````

For some reason that I don't understand, the Tk folks have never seen
fit to implement scrolled widgets such as a Scrolled Text
widget. Rather, the user is left to deal with scrollbar widgets and
attaching them to text or listboxes, I certainly don't want to fuss
around with all the separate programming tasks required for a scrolled
widget when building a GUI.

I am especially pleased that Guilherme Polo in his Pyttk-samples
package shows how to build Scrolledtext and Scrolledtreeview
widgets. Borrowing that code, I was able to include such widgets as
well as a Scrolledlistbox in PAGE.  In release 4.18, I was able to
extend his package so that the scrolled widgets now support mouse
wheel scrolling with the wheel scrolling in the y direction and
shift-wheel scrolling in the x direction.  Y direction scrolling
working in Linux, Windows, and OSX. However, X direction scrolling
only works in Linux and Windows. I do not understand why it does not
work in OSX and would welcome any incite.

One can select a scrolled widget from the Widget Toolbar and place it
in the GUI and PAGE will include all of the Python support coded
necessary to realize the scrolled widget. The scrolled widgets that I
added are not named with an T because they are not official ttk
widgets. The Scrolledtextbox has a normal text subwidget in which I
have chosen to make the "wrap" default "none".

Although Polo implemented his code with ttk widgets, I have used his
ideas to implement scrolled tk widgets as well. In fact, where
possible I have used tk widgets in preference to ttk widgets. For
instance, I have based only the ScrolledTreeview and Scrolledcombobox
on ttk widgets. I am indebted to Polo for his ideas but he bears no
responsibility for any errors I make interpreting his ideas.

The scrolled widgets are compound widgets containing as-needed
scrollbars and an elementary widget. As such, to set attributes or
apply bindings, first select the elementary internal widget.

When the scrolled widgets are placed into a container window, the
image shown displays vertical scroll bars to facilitate
identification. The best is that the appearance is similar to that
which is shown when the GUI is executed because as implemented in the
Python code the scroll bars appear only when required. I had a lot of
trouble with background colors in the ttk::scrollbars used in the
Python GUI. 

These widgets are complex widgets, so to move or resize them, use
Control with Button-1. The scrollbars are ttk::scrollbar widgets which
appear only when needed, i. e., when an item extends beyond the
allotted space.

When inserting text inside a Scrolledtext widget, treat it like a text
widget. For example, uses code like

.. sourcecode:: python

   obj = self.Scrolledtext1
   obj.insert(END, "This is text to be inserted")

When  cutting, or copying scrolled widgets, I use the widget tree for
easily selecting the whole widget rather than just the interior
widget.

To change attributes of the widget being scrolled, it is necessary to
select that widget from the Widget Tree and then make the desired
changes in the Attribute Editor. For instance, to change the
background color of a Scrolledtext widget, select the text widget
indented under the Scrolledtext entry in Widget Tree and change the
background color in the Attribute Editor.

The several scrolled widgets provide auto-scaling; that is when the
widget is actually larger than the viewing area scrollbars are
shown. However, there is no way for the user to change any attributes
of the scrollbars. This primarily affects the background color which is
the GUI background color which is set in the preferences.

ScrolledListBox
~~~~~~~~~~~~~~~

There s a slight problem with the ScrolledListBox in the way in which
the size function is invoked due to a strangeness, which I do not
understand, with multiple inheritance in Python. One would normally
expect to
get the value of size of a ScrolledListBox with the following statement:

.. sourcecode:: python

		size = w.Scrolledlistbox1.size()

However, that does not work as expected because the ScrolledListBox
class inherits from two classes Autoscroll and Listbox. Both classes
define the function "size" and the size that in invoked above is the
one via Autoscroll.  I have been unable to find a way of define "size"
in the ScrolledListBox class to be the one I want. So there are at
least two way of determining the size of a ScrolledListBox in a
support module. They are:

.. sourcecode:: python

	size = w.Scrolledlistbox1.size_()

	or

	size = tk.Listbox.size(w.Scrolledlistbox1)

The first works because I have added the definition of the function
"save_" to the ScrolledListBox class.  I do not know why I cannot add
a similar definition of "save".

.. _scrolledwindow:

ScrolledWindow
~~~~~~~~~~~~~~

This is my first attempt to provide a scrolled canvas widget. The
Scrolledwindow is a scrolled canvas with a single frame located in at
position (0,0) which can contain Tk widgets. Unfortunately, PAGE does
not give you much help in placing the widgets. And I have not been
able to get scrolling action when using the place geometry manager
with the widgets. 

I have used this widget for displaying photographs as part of a
photography library. It worked very well but I had to load the widgets
by adding Python code to the support module.

I think that this best
explained by example. I have included a simplified example to show
how I loaded the scrolledwindow and connected it to the
scrollbars. In the GUI module the following code is generated by PAGE:

.. sourcecode:: python

        self.Scrolledwindow1 = ScrolledWindow(top)
        self.Scrolledwindow1.place(relx=0.217, rely=0.311, relheight=0.522
                , relwidth=0.478)
        self.Scrolledwindow1.configure(background="#5eff8f")
        self.Scrolledwindow1.configure(borderwidth="2")
        self.Scrolledwindow1.configure(highlightbackground="wheat")
        self.Scrolledwindow1.configure(relief="groove")
        self.Scrolledwindow1.configure(selectbackground="#ddc8a1")
        self.color = self.Scrolledwindow1.cget("background")
        self.Scrolledwindow1_f = tk.Frame(self.Scrolledwindow1,
                            background=self.color)
        self.Scrolledwindow1.create_window(0, 0, anchor='nw',
                                           window=self.Scrolledwindow1_f)

The frame, self.Scrolledwindow1_f, is a container for tk widgets. The
following is code for inserting an array of buttons into that frame:

.. sourcecode:: python

    def init(top, gui, *args, **kwargs):
        global w, top_level, root
        w = gui
        top_level = top
        root = top
        load_canvas()
		
    def load_canvas():    
        inner_frame = w.Scrolledwindow1_f  # Rename for convenience.
        button = {}
        for i in range(12):
            button[i] = tk.Button(inner_frame, text='VButton'+str(i))
            button[i].grid(sticky='w')
        button[0].wait_visibility()      # Wait for widget to appear.
        bbox = inner_frame.bbox()        # Geometry of the frame.
        w.Scrolledwindow1.configure(scrollregion=bbox)    # Configure scrolling.

To see the GUI visit :ref:`sfimage`.
				

ScrolledTreeview
````````````````
There is a bug in Tcl/Tk which prevents the modification of the cursor
in contradiction of the ttk:treeview widget.

Ttk Notebook and PNotebook
`````````````````````````` 

If you select, place, and resize a TNotebook in
your GUI window it will display a notebook with two pages and may look like:

.. image:: notebook.jpg


To change the attributes of the TNotebook, select the notebook editor either
by invoking Control-Button-1 in the widget and then selecting edit
page from the Widget menu or by selecting it in the Widget Tree with
Button-3 and then the Widget entry in the popup menu.

.. image:: edit-pages.jpg

Here you can do all sorts of interesting things like change the text
in the tab and select the tab you want to activate for adding widgets
or changing attributes of widgets already added to that page. If you
go to the menu Item->Add, it will create a new page to the
notebook, in the above example, to the right of Page 2.  The Move
menu as well as the up and down buttons will change the order of the
pages.  The move operation will move the selected page one position up
or down.  The move is circular in the sense that moving the bottom
item down will move it to the top, etc.. 

Finally, the tab editor allows one to put an image on the tab as
shown.  The compound option allows the image to be placed in the
different position of the tab relative to the text.  The relationship
between an image and the text is governed by the compound option which
has a default value of "none". If left that way one will see the image
but no text. My recommendation is to select the image which should be
either a GIF or a PNG and then change the compound option to suit. While it is possible to
enter image object names into the image entry box, it is a bad idea to
do so. I have made the box orange as a warning.

Another way of navigating the pages in the tab editor is the pages
attribute in the Attribute Editor. The ellipse button invoked the tab
editor opens the tab editor.


With version 4.10, there is a variation of the Ttk Notebook called the
PNotebook which appears below:

.. image:: pnotebook.png

The x's at the right of the tabs are icons which will cause the tab
to close when selected with Button-1.  Note that this icon uses the
single image allowed in a tab and places it to the right.  So, the tab
editor does not have an image field to modify. It appears like:

.. image:: edit-pnotebook.jpg

When the support module is created for a GUI containing a PNotebook,
three funtions are added - "_button_press", "_button_release", and
"_mouse_over". Those names should be distinct from names that the user
might use in his application code. They were give the somewhat unusual
leading "_" character to facilitate the distinction.

.. _nbresize:

When it comes to resizing notebooks, it is necessary to recognize that
not all of the components can be resized. Consider the following
images.

.. image:: nb-selected.png

Here the notebook widget is selected. It' geometry may be changed by dragging a
handle or with the arrow keys.		   
		   
.. image:: nb-tab-sel.png

The widget selected here is an internal frame of the notebook tab and
its geometry may not be changed. And PAGE will not alter it.		   
		   
.. image:: Internal-widget.png

The selection is that of an internal widget in one of the notebook
tabs. Of course, it's geometry may be altered.		   
		   


Ttk Panedwindow
```````````````

The TPanedwindow can be added to the GUI by selecting it from the
Widget Toolbar and then Button-1 in the container.  There are two
entries for the TPainedwindow, one for vertical separators and another
for horizontal, in the Widget Toolbar.  It can be moved around by
Control-Button-1 and resized by dragging one of the handles. It is
sometimes a bit difficult grabbing a handle unless you select the
TPanedwindow widget from the Widget Tree window. Each pane of the
paned window contains a TLableframe which fills the pane.  Using the
label frame was the only way I could find to actually get the a
TPanedwindow to appear on my screen. Again, I had few examples to work
from. Documentation of the ttk::panedwindow is very poorly
documented, even worse than most other aspects of TTk.

The paned window is configured by invoking Widget->Edit Panes menu
item bringing up the following editor.

.. image:: pane-editor.png

This editor allows users to among among the panes, change the text in
the label frame, and to fix the relative weights used when resizing
the widget.  Changes made in the editor are applied to the GUI
immediately. Selecting the check button merely closes the editor.

One can select the TLableframe defining the pane and
drag the edge of it to change the sash position. In other words,
select a pane with Button-1 and drag one of the interior handles; that
will move the sash between the selected pane and the adjacent pane.

The Edit panes window allows one to add additional panes to the window
via the Item menu. The implementation of paned windows sets the
initial size of the paned window to 200x200 pixels and the first pane
size to 75 pixels.  Adding a new pane adds one at the end (the right
end of a horizontal TPanedwindow or the bottom of a vertical
TPanedwindow, in either case, taking space from prior end pane.
Fortunately you can resize the whole TPanedwindow which changes the
size of the end pane. Then resize the others by changing the sash
positions as described above.

The editor, by including the Move menu and the little up and down
arrows allows one can move the a pane to a new position. Again, the
move operation is circular.

To move a paned window select the whole window then a spot in a sash
between panes and then you can drag the whole paned window.

.. I am still having a problem with resizing TPanedwindows. If you select
.. the paned window, by say selecting it in the Widget Tree window, move
.. the paned window, and then select and move one of the handles, the
.. TPanedwindow will move rather than resize. However, if you again
.. select a handle it will resize the window. Obviously, something has
.. been set but not reset.  As soon as I figure out how to correct the
.. problem I will release a new version.

Ttk Treeview
````````````

It was  difficult to provide reasonably good support for the
Treeview widget. I actually do not support the ttk::treeview widget,
rather I have gone directly to the Scrolledtreeview which embeds the
ttk::treeview widget in a ttk::frame with auto-scrolling scrollbars.

What I have been able to do is to support the placement of the widget
in a window with a default of one column in addition to the tree
column both columns are stretchable. By invoking the column editor you
may change many of the characteristics of the widget such as the
column size and heading, as well as the number of columns. It also
allows one to reorder the columns.  Note that the column that contains
the tree has the index of "#0" and must remain the first (left-most)
column.  The column editor is invoked with Button-3 in the widget
within the Widget Tree and going to Widget->Edit Columns ... as shown
below:

.. image:: column-editor.png

If the widget were created or a column is added with the configuration
option "stretch" is set to 0 (not stretchable), then when the
resulting GUI is stretched then the column width will not change.  The
enclosing widget with the scrollbars will either have a blank area to
the right of the last column if the window is enlarged or the last
column will not fully show.  To get the more desirable behavior, go
into the Column Editor in the Widget menu and make at least one of the
columns stretchable.


Entry
`````

This widget is mostly like the simple widgets except that it supports
validation with three special options - validate, validatecommand, and
invalidcommand. See :ref:`validation commands <entrycmd>` for a
description of validate command specifications.  Note that the option
"validate" needs to be set because it defaults to "none".

Ttk Entry
`````````

While I do support the ttk entry widget, I don't see any reason to
recommend using it because I am unable to change the widgets font and
I don't like being stuck with the TkDefaultFont. Strange to say the
ttk Combobox, below, is rumored to be based on the TEntry widget and I
am able to manipulate the font size using the style facility.

.. _combo:

Ttk Combobox
````````````

The combobox requires a list of selectable values to display in the
drop-down listbox.  These are easily specified from the Set Values
entry of the Widget menu. When invoked from the menu a scrolled text
box appears and the values are specified by entering them one per line
in the text box and then selecting the check mark. Each line entered
is considered to be a string constant and will be enclosed in quotes
in the generate Python code. If you want values to include Python
variable then you should set the values in the support function. This
is a change from the previous behavior. Note that the window is a
text box and so on can use control-x, control-c, and control-v for
cut, copy, and paste.


.. The user should
.. include strings as they should appear in the Python code. That means
.. if they are string literals, then they should be enclosed in quotes as
.. shown in the example below. If the quoting is not present it is
.. assumed that they are variables. I do not want to get into the morass
.. of entry parsing literal strings.

.. image:: SetValues.png

Values can also be set in the "init" function in support module using
code like:

.. sourcecode:: python

	   w.TCombobox1['values'] = ('USA', 'Canada', 'Australia')


My style problem with the TCombobox is that while I can use the style
mechanism to change the font of the entry field in the combobox I
have not found a way to change the font of the drop down area
containing the values. In addition, I have not found a mechanism for
changing the values in the drop down list after initialization.

Note that the TCombobox widget incorporates an automatic height
scrollbar. Vertical scrolling should automatically enable once you
have sufficient values to choose between.


Radiobuttons
````````````

TRadiobuttons and Radiobuttons act pretty much the same. One specifies
several of the widgets which are linked by specifying the same Tkinter
variable for all. It is necessary to specify a different value for
each radiobutton. One can also specify an initial value for the group
by setting the initial value of the Tkinter variable in the support
routine.  For TRadiobuttons the values and variables can be specified
with the set method of the from the Widget menu as well as in the
Attribute editor.

According to Tcl/Tk documentation, Radiobuttons have a default
variable which is "selectedButton" bit I have not gotten that to work
in Tkinter.  So I recommend specifying your own variable in the
Attribute Editor and avoiding "selectedButton". I generate Python will
not fail with a syntax error if you do not specify a variable but it
will not truly work. I think that the problem is in the implementation
of tkinter.

The TRadiobutton is even worse; it cannot work with the default
variable which is "::selectedButton" because that is not a legal
Python identifier. So I fudge it to generate legal Python, but do not
expect it to work the same a specified variable.

Strangeness with Text and Variables 
```````````````````````````````````

I was surprised to discover a couple of strange things about the way
text is handled with ttk widgets.  There are several ttk widgets,
among them TButton, TMenubutton, TLabel, TCheckbuttom, and
Tradiobutton, which have both properties of "-text" and
"-variable". Using the Attribute Editor you can specify the value of
the Text to be displayed in PAGE when you are laying out the
GUI. However, if you then specify the variable attribute, the text
attribute is changed to the zero length string.  I guess that that is
because the variable you named is undefined.  But also the width of
the field containing the text may be set to zero length. So, for
instance, Tlables appear to have zero width unless you have changed
the width prior to specifying the variable.  A Tbutton merely displays
blank text and TRadiobuttons squeezes down to just the
button. TCheckbuttons behaves similarly to TRadiobuttons.

When you generate the Python code the widgets will again appear to
have no text and maybe have no width unless you have set a non blank
value into the Tkinter variable. Tk widgets including Button, Message,
Label, Checkbutton, and Radiobutton behave much the same way.

Label
`````  

Label widgets also treat text in an unexpected way.  The justify
attribute applies how multiple lines of text are aligned relative to
each other, it does not set how text lines are placed relative to the
Label widget boundaries.  Use the anchor attribute to specify if the
text block is up against the left of the widget (anchor 'e') or the
right (anchor 'w').

 
Listbox
```````

The Listbox widget has the option "listvariable" which one would expect to
behave exactly like one of the Tkinter variable classes.  However, the Tcl
documentation specifies that the listvariable must contain a list of
values to be displayed in the listbox and the possible Tkinter
variable classes are BooleanVar, StringVar, IntVar, and DoubleVar.  By
experimentation I have found that by specifying the var to be
StringVar and setting its value to a tuple of strings will cause each
member of the tuple to appear as an entry in the listbox.  I am rather
surprised at this but glad to find something that works.

The following code 

.. sourcecode:: python 

    def set_Tk_var():
        global rrr
        rrr = StringVar()
        rrr.set(('a','b','c','d','e'))



results in a scrolled list box looking like:

.. image:: Scrolled_List_Box.png

Spinbox
```````

The Spinbox widget has the option values which contains a list of
values presented in the widget as the arrows manipulated.  They are
set using the Widget menu item "Set Values".  When invoked from the
menu a scrolled text box appears and the values are specified by
entering them one per line in the text box and then selecting the
check mark.

.. _scale:

Scale and TScale
````````````````

Tk does strange things when one tries to modify the narrow dimension
of a scale widget (the height of a horizontal scale or the width of a
vertical one).  So PAGE does not allow one to modify the narrow
dimension during the design phase and restricts the Relative Placement
in the Python code to prevent changes in the narrow dimension.

As usual the command attribute specifies the callback function invoked
when the widget is selected. Unlike other widgets, the callback
function is invoked invoke whenever the scale's value is changed via a
widget command. So if you select the slider and drag it the callback
will be invoked numerous times. When the callback is invoked the
current value is passed as the first argument. If you want to pass
additional arguments then you should use a lambda function like:

.. sourcecode:: python

		lambda v: foo(v, 3)

where v is the current value of the slider.

This is similar to bind statements causing the passing of event objects.

TSeparator
``````````
The TSeparator widget when selected presents only three handles; one
at each end and one in the middle. The handles at the ends change the
length of the separator and the one in the middle moves the separator. 

I recommend investigating the trick by Greg Walters at
http://thedesignatedgeek.xyz/python/page/2018/06/04/How-To-Page-Separators.html.



Sizegrip
````````

Support for the ttk::sizegrip widget was included in Version 4.0.
Merely select the widget from the Widget Toolbar and drop it anywhere
within the Toplevel frame but not on top of another widget; it will
bounce to the lower right corner.  Were you to drop it on say a
notebook widget, a weird result would occur like landing in the wrong
place but doing the right thing.

I had difficulties with using Sizegrip with PAGE windows.  It works
fine with the Python Console and the Menu Editor, but I never got a
truly satisfactory result with Widget Tree or or the Widget Toolbar.
I left it with the Widget Toolbar but not with the Widget tree. To be
revisited.

Custom Widgets
``````````````

In writing a photo manager, I needed a variation of a scrolled canvas
to display photos.  I could not find a general purpose candidate for a
scrolled canvas widget, but a found several variations on the web that
might work. So I implemented support of user designed Custom widgets
that can be manipulate in PAGE but requires the user to supply the
Python implementation. So if I have left something out and you can
conjure a tkinter implementation of it, PAGE can handle it.

PAGE shows a Custom widget as a Text widget with the caption "Custom
widget" and which can be placed and resized like any other
widget. However since the widget has not been defined within PAGE, it
is meaningless to talk about modifying attributes in the Attribute
Editor except "variant" which is new in 4.15 and described below. With
release 4.15 the Attribute editor shows no other attributes. All other
attributes must be handled in the widget definition code.  The
generated Python refers to it as a class defined in the support
module.  To allow execution of the GUI before the support module is
completed, there is included in the support module the line:

.. sourcecode:: python

   Custom = Frame


The user then inserts his code for the custom widgets as a class with
the <class_name> of his choosing and follows that code with the line:

.. sourcecode:: python
   
   Custom = <class_name>

This is the magic that links the widget that you placed in the GUI
with the implementing class code in the support modules. See
:ref:`custom_example` example.

Of course, Python implementation of the custom widget may be in a
Separate Python module which can be imported into the support module.

With version 4.15, the notion of the Custom Widget has been extended
two ways. First it is now possible to have more than one custom widget
in a GUI.

And second, it is also possible to have more than one kind of custom
widget in the same GUI. Essentially what is implemented is a single
Custom widget with variations with each variation being realized with
a separate user-supplied Python implementation. To make that work,
PAGE has given the Custom widget the new attribute 'variant' which can
be modified in the Attribute Editor just like any other attribute for
any other widget. The variant attribute creates a separate name to be
used in the GUI module and tied to a separate Python widget
implementation. If the attribute is given a value (a name) then that
value is appended to the name 'Custom' and that enlarged name is used
as the class name in generating the Python code. If the variant
attribute is left blank, the class name is 'Custom' as before. For
instance, if the widget 'Custom1' in project 'd' is given the variant
'p' and the widget 'Custom2' is given the variant 'q', the following
lines are generated in the GUI module, 'd.py':

.. sourcecode:: python

    self.Custom1 = d_support.Customp(top)
    self.Custom1.place(relx=0.35, rely=0.24, relheight=0.16, relwidth=0.21)

    self.Custom2 = d_support.Customq(top)
    self.Custom2.place(relx=0.42, rely=0.62, relheight=0.16, relwidth=0.21)
			
and the following is generated in the support module 'd_support.py':

.. sourcecode:: python

	Customp = Frame

	Customq = Frame				

The names "Customp" and "Customq" are changed by the user to those of
the custom widget classes that he or she wishes to use and for which
the user supplies Python implementations. Thus one has two different
custom widgets in the GUI.  Obviously, the number of custom widgets is
not limited to two.

Think of it as a matter of names. In the code snippets above, Customp
is the name, or synonym, of a Class which is defined in the support
module, Custom1 is the name of the object or instance created by the
execution of the class Customp. If one wishes to operate instance
Customp in the support module, the instance is referred to as
w.Custom1.

In the support module the line:

.. sourcecode:: python

	Customp = Frame

renames the class to Frame, so that when one generates the GUI module
and the support module you can execute the GUI module and the Customp
widget is a Frame. Instantiating a "Customp" thus become the
instigation of a Frame class. When you get down to the brass tacks of
writing the "real" support module to use your own "Homegrown" widget
you can replace the above line of code or follow it with:

.. sourcecode:: python

	Customp = Homegrown

Having both lines of code is OK, it amounts to twice assigning a name
to Customp. Just make sure that last line follows the one with
Frame. The assignments are performed when the support module is
imported which occurs before the class Customp is instantiated so the
intended class definition, Homegrown, is used.

I urge you to look carefully at the :ref:`scrolledlistbox` example to
see a great example of using Custom widgets written by Greg
Walters. There is an extensive README also written by Greg
Walters. This example has one custom widget and several other PAGE
widgets.

.. _generate:

Canvas
``````

As stated on `effbot site <https://effbot.org>`_ the
Canvas widget provides structured graphics facilities for
Tkinter. This is a highly versatile widget which can be used to draw
graphs and plots, create graphics editors, and implement various kinds
of custom widgets.  The canvas is a general purpose widget, which is
typically used to display and edit graphs and other drawings.  Another
common use for this widget is to implement various kinds of custom
widgets. For example, you can use a canvas as a completion bar, by
drawing and updating a rectangle on the canvas.

PAGE support for this widget is somewhat 
limited. I claim little support for manipulating the interior of the widget.
One can do most things with the Canvas widget that can be done with
other widgets. The user can place, move, resize, etc.. Since the
Canvas widget is a container widget, any of the PAGE supported widgets
can be placed inside a Canvas widget.  

A Canvas widget has a lot of capabilities which PAGE does not support
such as drawing geometric shapes - such as lines, rectangles, circles,
ellipses, and arcs - adding text, or drawing with a mouse, or adding
images. Bindings to created elements is possible but are not supported by
the bindings editor. All of this stuff
must be manually added to the support module using tkinter
functions. To really support these capabilities would require writing a
entire GUI based graphical editing program as a sub system in PAGE.

The one thing that PAGE does provide is the :ref:`scrolledwindow`
widget which is a canvas with a window item at the upper left corner.

Generating, Inspecting, and Running the Python GUI
``````````````````````````````````````````````````
.. _saving:

Once the GUI has been defined, the next step is to generate the Python
modules.

Creating and Saving Code Modules
````````````````````````````````

This section discusses the creation and saving of the GUI module and
the support module. I want to make saving simple and intuitive while
reducing the probability of inadvertently overwriting hard to
reproduce code, particularly in the support module.  At the same time
I did not want to bombard the user with "Are you sure ..."
dialogues. These goals are somewhat contradictory. I would appreciate
comments on this subject.  I also want to ensure that GUI modules and
the project or tcl file are in sync. To do that I will save the tcl
file only when the user chooses to save the generated GUI module with
the Save button in the Python console. Note:
selecting the Run button implies the saving of the GUI module.  


When one chooses to generate the GUI module (Control-P or the Gen
Python menu):


+ The GUI is transformed into a Python module called the GUI module
  and displayed in the :ref:`Python Console` but is not automatically
  saved. This is to allow the user to peruse the code before
  committing it to storage.  The user may even change the code since
  the Python Console code window is a Tk text widget with some
  editing capability. 

..  
  
+ From the Python Console, the user can  select the Save button and
  the GUI module will be saved if "new" or changed.  Repeatedly
  selecting the Save button without changing the code will not result
  in additional actual saves. The constructed GUI is transformed into
  a Tcl file and saved if the GUI has changed in the current session. 

..  

+ From the Python Console, the user can select the Run button which
  provides the same function as the Save button but also attempts to
  execute the GUI module, if there is an existing support module. 



When one chooses to generate the Support module (Control-U):

+ The constructed GUI is transformed into a Tcl file and saved if the
  GUI has changed in the current session. 

+ If there is no existing support module, then one is generated and
  displayed in a Python Console. 

+ If there is an existing support module, action is a bit more
  elaborate. First, the existing support module is analyzed to see
  what Tkinter variable and functions are defined in the existing
  module and compared with those which would be defined in a new
  support module. Next, the user is given the choice of one of the
  following: 

        + use the existing support module, thereby preserving you hand written code,   

        + generate a new support module, 

        + update the existing support module to include the additional Tkinter variable and skeleton functions.  


+ From the Python Console, the user can select the Save button and the
  support module will be saved if new or "changed". 

+ From the Python Console, the user can select the Run button which
  provides the same function as the Save button but also attempts to
  execute the GUI module.

+ As stated above the project or tcl file is not saved.  


.. Generating the Python Modules
.. `````````````````````````````
.. 
.. Once the GUI has been defined, the next step is to generate the Python
.. code which will realize the GUI.  This is done from the Gen_Python
.. submenu of the main menu.  This will generate hopefully executable
.. Python modules and display them in Python consoles. 
.. Beginning with version 4.2, the Gen_Python submenu is used to generate
.. two Python modules, the GUI module <name>.py and support module
.. <name_support>.py, as discussed in the section on :ref:`rework`.  The
.. intention is that all or almost all of the algorithmic code of the
.. application will be in the support module and the code for building
.. the GUI will be in the GUI module. PAGE generates a complete and
.. hopefully working GUI module and a mere skeleton of the support module
.. with just enough code to allow the execution of the GUI module.
.. 
.. What happens on execution is that the GUI class will
.. be instantiated which means that the GUI will appear on the screen and
.. then control will pass to the "init" function in the support module
.. where the necessary code is written to support the function desired
.. with the GUI, i.e., the application.  So the workflow envisioned is:
.. 
.. + One will initially use page to generate the GUI module and a
..   skeletal support module.
.. 
.. + The user will then iterate modification of design and execution of
..   the GUI module until it contains the desired widgets with PAGE
..   generating both the GUI and the support module at each step.
.. 
.. + At that point, attention shifts to adding to the support module the
..   code to actually implement the application. At that point, the PAGE
..   user does not have PAGE regenerate the support module because that
..   would lose his hand written code. 
.. 
.. + At some point in the development of the application, the user is
..   likely to want modifications to the GUI. Make them but generate only
..   the GUI module and make manual changes to the support module changes
..   dictated by the GUI changes.  Mostly those changes will be to add to
..   the support module new functions for callbacks or new Tkinter variables,
..   etc..  A recent feature of PAGE will allow the user to update the
..   support module, meaning that new skeleton functions and Tkinter variables
..   will be added to the support module but no code will be
..   removed. Then iterate this last step until one is finished with the
..   application.
.. 
.. 
.. Generation of the modules is accomplished by selecting
.. Gen_Python->Generate GUI Module from the main menu. When selected, a
.. Python Console will open and display the generated module.  Similarly,
.. Gen_Python->Generate Support Module will open a different Python
.. Console displaying the support module.  Too keep the project file in
.. sync with the GUI file, the project file is saved when the GUI file is
.. generated. 
.. 
.. Similarly, when you select Generate Support Module from the menu, a
.. Python Console will appear, filled with the generated code for the
.. supporting module named "<name>_support.py".  Note: The support module
.. is generated by analyzing the saved GUI module. That means that the
.. GUI module must be saved before the corresponding support module can be
.. generated.  This file will contain skeleton functions and Tkinter
.. variables needed.  This file will contain the principal code for the
.. application. This, ideally, is generated automatically once per
.. application. Of course, generating the support module there is the
.. Update option discussed above.

It is important that the support file is not automatically saved when
run is invoked.  I don't want PAGE to inadvertently trash your
handwritten application code.  The Python Console has a label which
will indicates when the code window has been modified. That flag is
turned on any key is released over the window and that can indicate
changes which may not actually change the text,
i. e., a false positive.

PAGE does not utilize tab characters when saving files. With respect
to the ongoing controversy between tabs and spaces, PAGE is on the
side of spaces.  For this reason PAGE expands tabs when doing a save
from a Python Console.


Inspecting the Generated Python Modules
```````````````````````````````````````

Often the user will want to look at the code that exists for a
project. To do that, execute page with the project name or open the
project and the select Gen_Python->Load Python Consoles. This will
open two Python Consoles; one with the GUI module and the other with
the support module. The loading of the consoles is from appropriate
modules saved to disk. If a Python Console exists with either the GUI
or support module, it will not be overwritten. If one or the other has
not been saved, then nothing is done with the corresponding Python Console.

My guess that this is most interesting when the user has modified the
GUI and generated a new GUI module and wants to see what any existing
support module looks like.  Again, in this situation, the new GUI code
is not automatically saved.

Executing the Python Modules
````````````````````````````

To see what the GUI looks like, the user can run or execute the GUI
module. That can occur in two contexts, one is to execute the code
from one of the Python Consoles and the other is to load the modules
into an IDE and carry on development from there.  For execution within
PAGE there has to be a Python Console; the user can generate either
the GUI or the support module or load the project into the consoles
from the Gen_Python submenu.

To execute the GUI, select the Run button in a Python Console or using
the shortcut Control-R when the cursor is over a Python Console.

.. The generated GUI module is written in such a way that it will run
.. stand alone as a script provided that all the necessary stuff is
.. present. For instance, many of the widgets will have references to
.. command functions and callbacks that need to be present at least in
.. skeletal form for the generated Python to run stand alone. They may
.. also reference Tkinter variable classes which must be defined for the
.. Python to execute. That code will be included in the support module
.. along with the code to link the GUI module and the support module.
.. This means that one can expect the generated module to execute in the
.. sense that the GUI will appear.

Let me discuss the skeletal functions first. Function references may
be referenced in several ways. If the function name is given the
skeletal function will be created in the support module. An example
would be to specify the command attribute in PAGE as "george". In that
case, the skeletal support function "george" would be created in the
support module.  
.. If the specification were given as "self.george", the
.. skeletal module would created as a class function within the GUI
.. class. 
If another module were specified as in "app.george"
PAGE would not create a skeleton function at all; your on your own to
create and import the "app" module. From this you can see the need to
create the support module before trying to execute the GUI module.

Similarly, Tkinter variable classes are defined or the GUI class or in
the support module depending on the presence or absence of "self." at
the beginning of the specification.  If specified in the support
module, code is included to insure that the class is created before
the GUI execution references the class. 

Because the use of "self." in specifying functions and Tkinter variables
will require use code to be added to the GUI module, I avoid them in
my usage of PAGE.  Such specifications work against the benefits of
the rework facilities.

I frequently execute the GUI module to see how the Python version of GUI
looks. To that end, the support module is generated with very minimal
skeletal functions in order to check the appearance of the  GUI by
running from the Python console. The final lines of both the GUI
module are:

.. sourcecode:: python

	if __name__ == '__main__':
   	    vp_start_gui()

and the final lines of the support module are:

.. sourcecode:: python

	if __name__ == '__main__':
	   import name
	   name.vp_start_gui()


which will call vp_start_gui when the either module is executed. The key
is vp_start_gui which is generated automatically. It contains some
code like the following, where "unknown" is the default project name within PAGE:

.. sourcecode:: python 

    import unknown_support

    def vp_start_gui():
        '''Starting point when module is the main routine.'''
        global val, w, root
        root = Tk()
        root.title('New_Toplevel_1')
        root.geometry('600x450+650+150')
        unknown_support.set_Tk_var()
        top = New_Toplevel_1 (Interactive Design Environment)(root)
        unknown_support.init(root, top)
        root.mainloop()



The title above reflects the title attribute of the Toplevel window
and, of course, the geometry will reflect the location and sizes you
specify in placing the toplevel widget.

When you select the toplevel widget and Generate Support Module from the 
menu, the Python Console will appear, filled with the generated
code for the supporting module named "<name>_support.py".  This file
will contain skeleton functions and Tkinter variables needed.  This
file will contain the principal code for the application. 
.. This
.. is generated automatically once per application.


When you select the toplevel widget and Generate Python GUI from the 
menu, the Python Console will appear, filled with the generated
code. You can push the run button and execution will be attempted.
This will automatically save the generated code into a ".py" file
where the root name matches that of the tcl file which is also
automatically saved.  When running from the Python Window, line output
from the GUI is directed to the lower window of the Python Console.

.. A final word about running in a Python Window is that the ".tcl"
.. file will be automatically saved as well as the python file. If no
.. name has been selected for the project, then a file output window will
.. open and you will be presented with a window with which to specify the
.. tcl file name, the root of which will be used for the python file
.. name; it is a project name.  The tcl file can be used as an argument
.. to PAGE allowing one to later pickup where he left off.the script

Execution of the Python GUI is initiated by either selecting the "Run"
button at the bottom of the Python GUI or by typing Control-R. It can
also be run directly by the Python interpreter.

The function "init" is the place to initial things after the GUI 
is mapped.

Loading generated Python modules into an IDE
````````````````````````````````````````````

While it is possible to edit PAGE generated files in Python Consoles
and to execute them from there, the Python Consoles don't really
constitute a particularly good development environment. One should
move into a well concieved IDE like IdleX, emacs, Geany or any of a
host of similar programs.

PAGE can start up an IDE loaded with the Python modules that have been
saved. This is done by selecting Gen_Python->Load Project into
IDE. This does not automatically save modules from existing Python
Consoles.

The IDE is set in the Basics page of the Preferences.  PAGE tries to
execute a the IDE with two the two file names, <name>.py and
<name>_support.py, as arguments.  If your favorite IDE can be so
invoked then it should work.  When running under Linux or OSX, one can
enter either the full path name of the IDE or a command name in the
execution path. If you are on Windows, then the full path name takes
the a form with double backslashes like
"C:\\\\Python27\\\\Lib\\\\idlelib\\\\idle". I am not an expert in
Python IDE's, but I have successfully tested this facility with emacs,
vim, idle, and idlex on Linux; idlex in OSX, and idle in Windows.  For
instance, on Linux in the IDE command field I enter the full path of
the IDE. When I want to use IdleX under Linux I enter
/usr/local/bin/idlex.  I also found that I could enter idlex for
Linux.

The IDE is invoked from PAGE and PAGE goes into a wait
state until the IDE exits.

.. _Applications with Multiple Top-Level Windows:

Applications with Multiple Top-Level Windows
````````````````````````````````````````````

Often the user will want to build applications which have more than
one top level window.  Since PAGE is built for the specification of
only one such window how does the user proceed?  I think that the best
approach is to create separate modules for each top level window and
have the support module for the main GUI import them using import
statements. The windows can then be created using the create function
in the modules.  This approach was used for the Vrex example.
Here, I used PAGE to build skeletons for two separate program GUI's:

+ the vrex GUI module and associated vrex_support module. The vrex GUI
  module is the main module of the program.

+ the vrex_help GUI module and associated vrex_help_support module. 

I want the vrex_help GUI to appear when the "Help" button in the vrex
GUI is selected. The command for the "Help" button is the help routine
in the vrex_support.py Therefore, the following code in
vrex_support.py brings up the help window.

.. sourcecode:: python

   import vrex_help

   def help():
       vrex_help.create_Vrex_Help(root)	

Of course, there is very little interaction between the two programs
which simplifies things in this case. As in the example below, the
argument "root" ties the help window to the main window.

The same technique was used in the progress_bar example which shows
more interaction between the windows including the control of the
progress bar window from inside the main routine. Here the two
modules are main.py and progress_bar.py.  
In main.py we have

.. sourcecode:: python

   import progress_bar

   self.bar = progress_bar.create_Progress_Bar(root)

Here the parameter root ties the two
windows together and the create routine returns the Progress_Bar
object which allows the main GUI to access all of the functions and
attributes of the Progress_Bar object, in turn allowing the main GUI
to advance the bar and to close the progress bar.

Special functions are created in the python code to facilitate the
creation and destruction of the window.  


.. sourcecode:: python

    w = None
    def create_New_Toplevel_1(root, *args, **kwargs):
        '''Starting point when module is imported by another program.'''
        global w, w_win, rt
        rt = root
        w = Toplevel (root)
        top = New_Toplevel_1 (w)
        unknown_support.init(w, top, *args, **kwargs)
        return (w, top)
    
    def destroy_New_Toplevel_1():
        global w
        w.destroy()
        w = None


One can pass a variable number of parameters to the init function
of the support module using standard Python techniques built around
the "*args, **kwargs" usage. For instance, you might have code
like the following which I used in the :ref:`double` example :

.. sourcecode:: python

   p_dict_1 = {'geom': "+200+650", 'instance': 1, 'color' : 'firebrick'}
   p_dict_2 = {'geom': "+1000+650", 'instance': 2, 'color' : 'plum'}


   def open_two():
   	    print "open_two starts"
    	firebrick = called.create_Called(root,param=p_dict_1)
    	plum = called.create_Called(root,param=p_dict_2)


A common question is how to share global variables across module. A
good reference is `How do I share global variables across modules?
<http://effbot.org/pyfaq/how-do-i-share-global-variables-across-modules.htm>`_.

.. In the examples directory I have included a photo library example
.. which is fairly complex illustrating some of the ideas here.

If you dynamically create secondary widgets and want to be sure you
only have one instance of say form2, you can use the following code:

.. sourcecode:: python

    import form2
    # If form2 already exists then destroy it and create it anew. I only want
    # one. So I play games with form2_w.
    global form2_w
    if 'form2_w' in globals()
        print 'its there'
        form2_w.destroy()
    (form2_w, form2_top) = form2.create_New_Toplevel(root)

	


Busy Cursors
````````````

This section describes how to change the cursor when in long running
sections of an application.  Changing to a busy cursor gives some
feedback to the application user who otherwise may think that the
application is hung, not doing anything.

One includes the following code at the module level of the support module:

.. sourcecode:: python

    # Code added to allow one to change default cursor to a busy cursor.
    # Variables added manually to indicate long processes based on code by
    # Greg Walters in his python programming examples.  These routines
    # also can be seen in the Greyson book pg. 158.
    busyCursor = 'watch'
    preBusyCursors = None

    def busyStart(newcursor=None):
        '''We first check to see if a value was passed to newcursor. If
           not, we default to the busyCursor. Then we walk through the
           busyWidgets tuple and set the cursor to whatever we want.'''
        global preBusyCursors
        if not newcursor:
            newcursor = busyCursor
        newPreBusyCursors = {}
        for component in busyWidgets:
            newPreBusyCursors[component] = component['cursor']
            component.configure(cursor=newcursor)
            component.update_idletasks()
        preBusyCursors = (newPreBusyCursors, preBusyCursors)
    
    def busyEnd():
        '''In this routine, we basically reset the cursor for the widgets
           in our busyWidget tuple back to our default cursor.'''
        global preBusyCursors
        if not preBusyCursors:
            return
        oldPreBusyCursors = preBusyCursors[0]
        preBusyCursors = preBusyCursors[1]
        for component in busyWidgets:
            try:
                component.configure(cursor=oldPreBusyCursors[component])
            except KeyError:
                pass
            component.update_idletasks()
    # End of busy cursor code.

and the following lines of code are inserted in "init" in the support module:

.. sourcecode:: python

    global busyWidgets

    busyWidgets = (top, )

The first line goes in near the top of the function and the assignment
to busyWidgets is inserted after the root object is created. In one of
my applications the function "init" looks like:

.. sourcecode:: python

    def init(top, gui):
        ''' Function to create the thread for periodically updating the GUI.'''
        global t
        global w, top_level
        global busyWidgets
        w = gui
        top_level = top
        t = threading.Thread(target=fill_window,)
        t.start()
        busyWidgets = (top, w.Scrolledtext1)

The final line above sets the global variable busyWidgets to be a
tuple of those widgets I wish to display the busy cursor.  This is
from the example :ref:`wcpe` where I want the busy cursor to appear
in the top level window as well as the Scrolledtextbox.

When starting a section of code which is likely to be long running, a
busy section, insert the following at the start:

.. sourcecode:: python
   
   busyStart()

When leaving a busy section make the following the last statement():

.. sourcecode:: python
   
   busyEnd()

Obviously, an application could have numerous busy sections and they
might coincide with particular functions or not.


This code can be generalized for usage of any of the Tkinter cursors.


.. Final Thought on Usage
.. ~~~~~~~~~~~~~~~~~~~~~~
.. 
.. When one feels confident in using PAGE, he looks at the code patterns
.. generated by PAGE and modifies the code for effects not anticipated in
.. PAGE. The philosophy of PAGE is that there is a large and intimidating
.. body of information needed to start building a GUI. PAGE encapsulates
.. that information and produces working code. At that point the user can
.. see the direction the flow is taking and can easily customize the
.. code at the python level.

.. _images:

Using Images
````````````

The use of images within PAGE is confusing. The good news is that you
can use images with various widgets such as buttons, menus, and
TNotebooks. You can select image files by means of the Attribute
Editor for Buttons, and the Tab Editor for Notebooks. Similarly,
the Menu Editor will allow you place images in menus.

Images are specified by means of the image attribute in the Attribute
Editor where the ellipses button allows one to select an image
file. The location of the image file is retained relative to the
project directory. For that reason, put your GUI images in the project
directory.

Now for the confusing part.  You can most easily use images as long as they
are GIF, PGM, or PNG images but not JPG or other image formats.  This
is because Tcl/Tk 8.6 only supports GIF, PGM, or PNG image formats. 

With the Img package installed, a large number of images formats
are available including the JPG format. Fortunately, the ActiveTcl
packages as well as the Magicsplat packages include Imp. However,
Raspbian users will have to install the libtk-img package using
something like

.. sourcecode:: python

   	sudo apt-get install libtk-img

In order for the generated Python code to support a wide range of
image formats including JPG, it is necessary to install PIL, the Python
Imaging Library. The Python package which provides PIL is Pillow and
may be obtained at 	https://pypi.org/project/Pillow/2.2.1/. Raspbian
users may install the "python-pil" package using

.. sourcecode:: python

   	sudo apt-get install python-pil


When PAGE includes a image, a image object is created and given a name
based on the file name. For example, the object name based on the file
"gimp.png" would be "gimp_png". That object is used in widget
configurations.  When you select an image button in the Attribute
Editor and select an image file, an image object is generated and its
name is displayed in the image entry field. Though the names could
conceivably be added manually into the image entry fields of the
attribute editor, I think that is a bad idea; so bad, in fact, that I
have since version 4.10 disabled those entry fields. You must make your
image choices by means of the ellipsis button next to the entry field.
I have also colored the entry field so that you realize that it is a
no-no. Comments again are welcome. This restriction creates a problem;
once you add an image to a widget you cannot remove the widget by
clearing the image field. However, you can remove an image by invoking
the widget context menu with Button-3 and then selecting
Widget->Remove Image. The Menu Editor and other similar editors do
allow the removal of an image by clearing the image entry field.

The project file and generated Python code reference all image files
images used.  Those file references are relative to the project
directory.  It is almost a requirement that the images to be used be
in the same directory as the one where you build the application or
even better a subdirectory of that directory. This will facilitate
moving the project or sharing it. So keep the images and projects
together. See the :ref:`projdir`.

Also, the image option is coupled with the compound option which
specifies the relationship of the image position with that of text. 
The Tk default value is "none", which means that if both text and an
image are specified then the widget will display only the image. In
a nutshell if "none" is selected then only the image appears, other
wise both image and test appears.  For button widgets, I mostly want
to select "none" for the compound value, but for menus and notebook
widgets "left" is my usual choice.

As of version 4.24, it is possible to cut-copy-paste widgets with
images provided that the images are already in the destination project
directory in the same relative location. For example, if the widget to
be copied contains an image in location "./images" then the image must
be in "./images" in the destination project directory prior to the
paste operation. This is also true when the cut-copy-paste operation
is part of a borrow operation.

Similarly, if you distribute a application using widget images, the
receiver must keep the application and its widget images in the same
relative location.

.. _dynamic_widgets:

Dynamic Widgets
```````````````
At times the user wants widgets to display dynamic behavior.  That
might mean changing color of a widget, the bindings of a widget, the
visibility of a widget, or the placement of a widget.  This can all be
done within the support module.

To change an attribute of say Button1, the code would be

.. sourcecode:: python

		w.Button1(background='red')


To change a binding:


.. sourcecode:: python


		w.Button.bind(<Button-3>, lambda e: foo(e,x,g)

To hide Button1:


.. sourcecode:: python

    b_location = w.Button1.place_info()		
    w.Button1.place_forget()

To restore the visibility of Button1:

.. sourcecode:: python


		w.Button1.place(relx=b_location['relx'], rely=b_location['rely'])





