.. _rework:

Rework
======

Rework
~~~~~~

With version 4.2, I turned my attention to facilitating rework in
PAGE.  That is, how do you use PAGE to tweak the GUI without loosing
the supporting code that you have written? At the same time I want to
allow one to view the changes with the run command button in the
Python console.

Here is the situation.  You design a GUI and generate the Python code
using PAGE, which creates skeleton functions.  You then fleshed out
the skeleton functions to support the GUI and then decided to modify
the GUI.  If then you again generate the Python code for the GUI, you
do not want to loose the application code which you have written to
realize the application.  This is the rework problem: How to keep your
hard fought code when reworking the GUI?

Starting with version 4.2, I have tried to separate as completely as
possible the automatically generated GUI code from the added support
code.  My approach is to create the generated GUI code in one Python
module and the supporting code including skeleton functions and Tk
variables in a separate Python support module to be imported by the GUI
module.  That is, now PAGE generates two Python modules, one for the
GUI and one for the supporting code complete with the necessary
linkage.

PAGE implements this schema as follows.  PAGE now works with three
files:

+ "<name>.tcl" which is the design description of the GUI suitable for input to PAGE. It can either be created in PAGE, passed to PAGE as a parameter, or opened from the File submenu of the main menu.

+ "<name>.py" which is the main python module generated by PAGE which contains the automatically code to create the GUI on the screen. It is meant to be completely generated by PAGE. This will be referred to as the GUI module.

+ "<name>_support.py" which contains the code supporting the GUI module. PAGE creates a skeleton of this module that contains all of the necessary boiler plate code for linkage to the GUI module as well as the definitions of the Tkinter variables and skeleton versions of callback routines.  I will be referring to this as the support module.

In the above, "<name>" is the application name (it was called the
project name in the original Visual Tcl program) selected by the user
when the system saves the ".tcl" or extracted from the file name which
may be supplied as a parameter when invoking PAGE.

It is expected that the user will generate a new version of the GUI
module whenever he modifies the GUI but will need PAGE to modify the
support module only when new Tkinter variables or callback functions are
defined. The first will be much more frequent than the
latter. Further, version 4.3 provides a mechanism for updating the
support module by adding the new Tkinter variables and callback functions
skeletons to an existing support module.

Generation of either Python module will attempt to save the tcl file
and in so doing may ask if you really want to save it. If you do not
answer "yes" the root file name may not be known and bad code could be
generated.

Let me repeat: You should only generate the support module once for an
application; otherwise any code which you manually added will be lost.
Well, just in case you do that inadvertently, PAGE will save some
previous versions as backups.  If you add new or change widgets in the
GUI or modify callback functions or Tkinter variables changes will have to be
made to the support module.

When saving the support module PAGE will test to see if a support
module with the same name exists and if it does, it will question the
user as to whether he wishes to continue and if continue, whether to
replace or update the module.

For an example of the separation of the GUI module from the support
module, see the WCPE directory in the examples directory.  This is a
program that displays the program of WCPE which is one of my favorite
classical music stations.  In this example all of the functional code
is located in WCPE_support.py and the GUI design is recorded in WCPE.py
which is the main module.  I found it very tricky to deal with time
zones and did not want to loose any of that code and have to redo it
or to deal with diffs; at the same time, I was constantly tweaking
the GUI.  I generated the import module once and proceeded fill out
the "init" function and the callback functions in WCPE_support.py while
tweaking the GUI, i.e., changing its location, color, the size of the
display fields, fonts, etc..

It may be instructive in that it exemplifies an application comprised
of two top level windows where one of the windows accesses Tkinter
variables in the second window.

With chagrin, I apologize to the PAGE users for not having thought of
this solution to rework long ago.  Even though I have tested the idea
with several examples, some of which are included in the section on
examples, I worry that I have overlooked something big.  So if you
find any problems or oversights, please let me know.

Automatically Updating the Support Module
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The is the new feature of PAGE introduced with version 4.3.  The basic
idea is that reworking the GUI design may introduce new callback
functions, Tkinter variables, or custom widgets which need to
incorporated into the support module. PAGE can now add those entities
to the support module.  That is, new skeletal functions are added and
new entries are added to the set_Tk_var function, if necessary the
set_Tk_var function is added. Similarly, new rename statements for
added custom widgets are added. All this while leaving the rest of the
existing support module unchanged.

If Control-U was selected to generate the support module, then the
user will be given the options of:

+ generating the support module anew, 

+ using an existing support module, thereby utilizing the existing handwritten code; the old support module will be displayed.

+ updating an existing support module to preserve the existing code and adding new Tk Variables or skeleton callback functions.  

To rephrase the above, when the user selects Gen_Python->Generate
Support Module from the main menu or selects Control-U, PAGE will
analyze an existing support module and compare the callback functions
and Tkinter variables in it with those utilized in the reworked
design.  If new entities are required the user will be given the
option of automatically adding them.  Existing code is not removed or
modified.  It is up to the user to remove or otherwise deal with code
no longer needed.

The first step in this process the existing support module is analyzed
to determine new skeletal functions, Tkinter variables, or custom
widget renames required.  Next, step 2, the existing support module is
read in and the new code is added.  Following inspection in the Python
console, the user may elect to save the updated module.

At the present time, through version 4.16, there is an issue with tab
characters. In step 2, tab characters are not expanded while the added
code will use spaces for indentation and that could cause syntax
errors through misalignment. This will be addressed in the next
release. In the meantime, you should remove any tabs in support
modules before attempting updates.

To mitigate case where the update process damages an existing support
module, PAGE keeps several backups.

.. 
.. Saving of Modules
.. =================
.. 
.. One possibly confusing aspect of PAGE is the saving of the three files
.. associated with a PAGE GUI:
.. 
.. + The tcl file which is the input to the "working" or "design" file of PAGE.
.. + The Python code generated defining the GUI object.
.. + The Python support file containing much of the boiler plate and skeleton functions. 
.. 
.. PAGE implements several mechanisms for saving these files as discussed below.
.. 
.. As stated elsewhere the root name is derived from the name of the tcl
.. file. The Python GUI design file root name is the same as that of the
.. tcl file and the Python support module is that root name concatenated
.. with "_support".
.. 
.. When either the Python GUI module or the support module are saved,
.. existing modules are retained as backups. Up to five backup modules
.. are retained to help avoid inadvertent lose of application code.
.. 
.. Code from the support Python Console source window is not automatically saved,
.. the user must select either the Save or Run button of the Python
.. Console. If the user makes a mistake and saves the support module
.. code, there are a series of backup files with file types bak1, bak2,
.. ... up to bak5, from which an earlier version can be resurrected.
.. 
.. Note: Some users have experience problems when saving PAGE modules. In
.. my case I resolved the problem by using the ActiveTcl package rather
.. than the package installed with the system.
.. 
.. Save Command in the Menu
.. ~~~~~~~~~~~~~~~~~~~~~~~~
.. 
.. When File->Save or File->Save As is selected then the tcl file is
.. saved provided the GUI has changed since the last save action or the
.. loading of an existing GUI file. The previous version of the tcl file
.. is made a backup file.  It does not save either the GUI module or the
.. support module.
.. 
.. 
.. Save Button in the Python Console
.. ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. 
.. When the Save button in the GUI Console file is selected, the tcl file is
.. saved as above if there has been a change to GUI. Also, the content of
.. the top window of the Python GUI Console is saved if it is different from
.. the last version of the code that was saved.  That is, if the Python
.. console contains GUI code then the GUI module will be saved if it has
.. been modified since the last save of the GUI code in the current PAGE
.. invocation. By modified I mean changed via editing operations in the
.. text field or regenerated by PAGE.
.. 
.. Similarly for the case of the support module being in the
.. Python Console, if:
.. 
.. + the user had generated a new version of the support module, 
.. 
.. + had the user upgraded the support module,
.. 
.. + the user had elected to use the existing support module and had modified it by editing the source window.
.. 
.. then support module will be saved and existing support modules will be
.. renamed and retained as backup files.
.. 
.. Run Button in the Python Console
.. ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. 
.. When the Run button is selected the code in the Python Console will be
.. saved if it differs from the last save in the current invocation of
.. PAGE. If the code in the source window is GUI code it saved as the GUI
.. module subject to the rules above; if it is support code it will be
.. saved as the support module as above.
.. 
.. Then the GUI module is execute by invoking the Python Interpreter
.. against the saved GUI .  Running the Python GUI code will show the
.. actual GUI.  Obviously it will fail if there is no support module. I
.. don't think it makes sense to try executing the support module from
.. the Python Console because there are much better venues for debugging
.. the support code.
.. 
.. .. The save logic which I have implemented is fairly complex; I have included
.. .. below the code which is part of PAGE.
.. .. 
.. .. .. sourcecode:: python
.. .. 
.. ..     proc vTcl:test_file_content {filename new_content} {
.. ..         # Function to determine if we can safely skip the save function.
.. ..         # A return value of 0 means that we can skip the actual save.
.. ..         # A return value of 1 means that we must save. 
.. ..         global vTcl
.. ..         set save 1
.. ..         set skip 0
.. ..         # If the Python file does not exist, we clearly have to save it.
.. ..         if {[file exists $filename] == 0} {     
.. ..             return $save
.. ..         } 
.. ..         # If the content of the code window is unchanged, we can skip the save.
.. ..         if {$new_content == $vTcl(last_save,$vTcl(python_module))} {
.. ..             return $skip     ;# Skip the save.
.. ..         }
.. ..         # If we got this far then we want to save.
.. ..         return $save     ;# Do the save.
.. ..     
.. ..     }        
.. 
.. Note that every time that the Python code for either the GUI or the
.. support module is generated the new module will include a current
.. timestamp and so comparing will two generations will always differ if
.. only in the timestamps. Without the timestamps I could probably reduce
.. the number of saves and backup files, but I think the timestamps are
.. very valuable.
.. 
.. 
.. 
.. Automatic Save at PAGE Exit 
.. ~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. 
.. When PAGE is closed by either Quit, Control-Q, or Control-C, the save
.. action is the same as for the File->Save. Again, the GUI module and
.. the support module are not affected or saved.
..   

.. _reuse:

Reuse
=====

By reuse, I mean the using of widget definitions used and defined in
previous PAGE projects.  The two aspects of reuse are:

+ Using existing projects as templates.

+ Borrowing widget definitions from existing projects.

Templates
~~~~~~~~~

Very simple, just load the project you want to use as a template and
do a "Save As..." from the main menu providing the name of the new
project. Of course, you will have to copy any images used in the
template to the directory of the new project.

.. _borrow:

Borrowing Widgets from Existing Projects
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

With borrowing one retrieves and opens an existing project, which I
will refer as the Lender GUI, at the same time as the current project
is open and then copies elements from the existing GUI and pastes them
onto the current GUI. For instance one might have a frame with and
array of buttons in one GUI and would like to replicate it in another
project.  

PAGE will only build projects with one GUI, but with this new
capability introduced in version 4.10, the user can open up the GUI
from an existing project and use that GUI as a source of widget
definitions using the existing cut, copy, and paste functions.  This
facility is invoked by selecting the Borrow command from the File
menu.

The Lender GUI is read only in the sense that the save functions will
ignore it, leaving it unchanged on disk.  So don't worry about changes
you might make to the Lender GUI.  By the same token you cannot make
changes to the Lender GUI that you would like to save.

The Lender GUI is opened via File->Borrow menu entry. When it is
opened, the toplevel background is set to Plum so that the user will
recognize it as a Lender GUI.  I chose Plum because I doubt that many
users will choose Plum as a toplevel background color. It is possible
even likely that the Lender GUI will overlap or obscure the current
GUI under construction; in that case just move it to the side to
expose the current GUI.  

This feature required a minor change in the format of the project tcl
file. That means that a project file created before version 4.10 will
need to be opened and saved before it can be a lender. Remember to use
"Save as" instead of "Save" which only saves if the main GUI has been
changed.

A peculiar side effect of borrowing is that if the Lender GUI happens
to have context (popup) menus, they will be incorporated in the main
GUI. That is because every bit of documentation that I could find on
context menus used root as the parent rather than a Toplevel window;
so I did too. This may not be too bad because if you don't bind to
them they will never be invoked. Further, if you borrow a widget which
is bound to a popup you will likely want to pull over the menu as well
as the widget. If not wanted context widgets are easily deleted from
the Widget Tree.  Comments solicited.

With version 4.11, the Menu Bar from the Lender GUI may be copied and
pasted into the current GUI. To do that 

*  Select the Menu Bar entry in the Widget Tree with Button-3 and 
   then the Copy entry of the popupmenu, select the toplevel window 
   with Button-3. 

*  Select the Copy entry in the popup window.

*  Select the Toplevel GUI window with Button-3.

*  Select the Paste entry in the popup window.

*  Press Button-1 anywhere in the Toplevel GUI window.

If any of the borrowed widgets have images, then the image files must
be copied to the new project directory **before** the paste operation
and they must be in the same relative position in the new project
directory. That is, if the image path was, for instance
"./images/image.png" then the image path in the new directory should
also be "./images/image.png". If the image files are not in place
before the paste operation, the past operation will fail.
   
When finished with a lender GUI, one is tempted to close the window by
means of the little "x" in the corner.  The better way is to select
the toplevel widget and use "Delete" command in the widget menu
obtained by Button-3.

Care must be exercised in borrowing widgets with images. After the
borrow is completed, any image reference must be updated to refer to
images in the destination project directory.  Also, check any variable
attributes.
   
Borrowing is a new function, so please report any problems encountered.
